
fs_fat32.kmod:     file format elf32-i386


Disassembly of section .text:

00000000 <_ZN8fs_fat3215sector_for_fileEPcj>:
}

/*
 * Gets the sector, relative to the start of the partition, for a certain file.
 */
unsigned int fs_fat32::sector_for_file(char *path, unsigned int offset) {
       0:	55                   	push   %ebp
       1:	89 e5                	mov    %esp,%ebp
       3:	83 ec 18             	sub    $0x18,%esp
       6:	a1 00 00 00 00       	mov    0x0,%eax
       b:	89 45 f4             	mov    %eax,-0xc(%ebp)
       e:	31 c0                	xor    %eax,%eax
	return 0;
      10:	8b 55 f4             	mov    -0xc(%ebp),%edx
      13:	33 15 00 00 00 00    	xor    0x0,%edx
      19:	75 02                	jne    1d <_ZN8fs_fat3215sector_for_fileEPcj+0x1d>
      1b:	c9                   	leave  
      1c:	c3                   	ret    
      1d:	e8 fc ff ff ff       	call   1e <_ZN8fs_fat3215sector_for_fileEPcj+0x1e>
      22:	66 90                	xchg   %ax,%ax

00000024 <_ZN8fs_fat3221contents_of_directoryEPc>:
}

/*
 * Reads a directory, and constructs an fs_directory_t object for it.
 */
fs_directory_t *fs_fat32::contents_of_directory(char *path) {
      24:	55                   	push   %ebp
      25:	89 e5                	mov    %esp,%ebp
      27:	57                   	push   %edi
      28:	56                   	push   %esi
      29:	53                   	push   %ebx
      2a:	83 ec 2c             	sub    $0x2c,%esp
      2d:	8b 75 0c             	mov    0xc(%ebp),%esi
      30:	8b 5d 08             	mov    0x8(%ebp),%ebx
      33:	a1 00 00 00 00       	mov    0x0,%eax
      38:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      3b:	31 c0                	xor    %eax,%eax
	// Allocate a directory entry
	fs_directory_t *directory = hal_vfs_allocate_directory(true);
      3d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
      44:	e8 fc ff ff ff       	call   45 <_ZN8fs_fat3221contents_of_directoryEPc+0x21>

	// Separate path string
	list_t *components = this->split_path(path);
      49:	89 74 24 04          	mov    %esi,0x4(%esp)
      4d:	89 1c 24             	mov    %ebx,(%esp)
/*
 * Reads a directory, and constructs an fs_directory_t object for it.
 */
fs_directory_t *fs_fat32::contents_of_directory(char *path) {
	// Allocate a directory entry
	fs_directory_t *directory = hal_vfs_allocate_directory(true);
      50:	89 c7                	mov    %eax,%edi

	// Separate path string
	list_t *components = this->split_path(path);
      52:	e8 fc ff ff ff       	call   53 <_ZN8fs_fat3221contents_of_directoryEPc+0x2f>

	// Iterate over each component
	for(unsigned int i = 0; i < components->num_entries; i++) {
      57:	8b 50 08             	mov    0x8(%eax),%edx
fs_directory_t *fs_fat32::contents_of_directory(char *path) {
	// Allocate a directory entry
	fs_directory_t *directory = hal_vfs_allocate_directory(true);

	// Separate path string
	list_t *components = this->split_path(path);
      5a:	89 c6                	mov    %eax,%esi

	// Iterate over each component
	for(unsigned int i = 0; i < components->num_entries; i++) {
      5c:	85 d2                	test   %edx,%edx
      5e:	74 3b                	je     9b <_ZN8fs_fat3221contents_of_directoryEPc+0x77>
      60:	31 db                	xor    %ebx,%ebx
      62:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
      69:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		char *component = (char *) list_get(components, i);
      70:	89 5c 24 04          	mov    %ebx,0x4(%esp)

	// Separate path string
	list_t *components = this->split_path(path);

	// Iterate over each component
	for(unsigned int i = 0; i < components->num_entries; i++) {
      74:	43                   	inc    %ebx
		char *component = (char *) list_get(components, i);
      75:	89 34 24             	mov    %esi,(%esp)
      78:	e8 fc ff ff ff       	call   79 <_ZN8fs_fat3221contents_of_directoryEPc+0x55>
		KDEBUG("%s", component);
      7d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
      84:	89 44 24 08          	mov    %eax,0x8(%esp)
      88:	b8 ac 0e 00 00       	mov    $0xeac,%eax
      8d:	89 44 24 04          	mov    %eax,0x4(%esp)
      91:	e8 fc ff ff ff       	call   92 <_ZN8fs_fat3221contents_of_directoryEPc+0x6e>

	// Separate path string
	list_t *components = this->split_path(path);

	// Iterate over each component
	for(unsigned int i = 0; i < components->num_entries; i++) {
      96:	39 5e 08             	cmp    %ebx,0x8(%esi)
      99:	77 d5                	ja     70 <_ZN8fs_fat3221contents_of_directoryEPc+0x4c>
		KDEBUG("%s", component);
	}

	// Return directory
	return directory;
}
      9b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
      9e:	33 15 00 00 00 00    	xor    0x0,%edx
      a4:	89 f8                	mov    %edi,%eax
      a6:	75 08                	jne    b0 <_ZN8fs_fat3221contents_of_directoryEPc+0x8c>
      a8:	83 c4 2c             	add    $0x2c,%esp
      ab:	5b                   	pop    %ebx
      ac:	5e                   	pop    %esi
      ad:	5f                   	pop    %edi
      ae:	5d                   	pop    %ebp
      af:	c3                   	ret    
      b0:	e8 fc ff ff ff       	call   b1 <_ZN8fs_fat3221contents_of_directoryEPc+0x8d>
      b5:	90                   	nop
      b6:	66 90                	xchg   %ax,%ax

000000b8 <_ZN8fs_fat32D1Ev>:
}

/*
 * Clean up the filesystem's internal data structures, and cleanly unmount it.
 */
fs_fat32::~fs_fat32() {
      b8:	55                   	push   %ebp
      b9:	89 e5                	mov    %esp,%ebp
      bb:	83 ec 18             	sub    $0x18,%esp
      be:	a1 00 00 00 00       	mov    0x0,%eax
      c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
      c6:	31 c0                	xor    %eax,%eax
      c8:	8b 45 08             	mov    0x8(%ebp),%eax
      cb:	c7 00 08 00 00 00    	movl   $0x8,(%eax)

}
      d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
      d4:	33 05 00 00 00 00    	xor    0x0,%eax
      da:	75 02                	jne    de <_ZN8fs_fat32D1Ev+0x26>
      dc:	c9                   	leave  
      dd:	c3                   	ret    
      de:	e8 fc ff ff ff       	call   df <_ZN8fs_fat32D1Ev+0x27>
      e3:	90                   	nop

000000e4 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory>:

/*
 * Converts FAT32-style directory entries into fat_file_t or fat_directory_t
 * objects, and adds them as children of the specified directory.
 */
void fs_fat32::processFATDirEnt(fat_dirent_t *entries, unsigned int number, fs_directory_t *root) {
      e4:	55                   	push   %ebp
      e5:	89 e5                	mov    %esp,%ebp
      e7:	57                   	push   %edi
      e8:	56                   	push   %esi
      e9:	53                   	push   %ebx
      ea:	81 ec ac 06 00 00    	sub    $0x6ac,%esp
      f0:	8b 4d 14             	mov    0x14(%ebp),%ecx
      f3:	8b 55 10             	mov    0x10(%ebp),%edx
      f6:	a1 00 00 00 00       	mov    0x0,%eax
      fb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      fe:	31 c0                	xor    %eax,%eax
     100:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	// Sanity checking
	ASSERT(root);
     103:	85 c9                	test   %ecx,%ecx

/*
 * Converts FAT32-style directory entries into fat_file_t or fat_directory_t
 * objects, and adds them as children of the specified directory.
 */
void fs_fat32::processFATDirEnt(fat_dirent_t *entries, unsigned int number, fs_directory_t *root) {
     105:	89 95 74 f9 ff ff    	mov    %edx,-0x68c(%ebp)
     10b:	89 8d 68 f9 ff ff    	mov    %ecx,-0x698(%ebp)
	// Sanity checking
	ASSERT(root);
     111:	0f 84 84 04 00 00    	je     59b <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x4b7>
	ASSERT(entries);
     117:	85 db                	test   %ebx,%ebx
     119:	0f 84 9f 04 00 00    	je     5be <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x4da>

	if(!number) {
     11f:	8b 85 74 f9 ff ff    	mov    -0x68c(%ebp),%eax
     125:	85 c0                	test   %eax,%eax
     127:	0f 84 d3 00 00 00    	je     200 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x11c>
     12d:	31 c0                	xor    %eax,%eax
     12f:	31 f6                	xor    %esi,%esi
     131:	c6 85 60 f9 ff ff 00 	movb   $0x0,-0x6a0(%ebp)
     138:	89 85 64 f9 ff ff    	mov    %eax,-0x69c(%ebp)
     13e:	c6 85 70 f9 ff ff 00 	movb   $0x0,-0x690(%ebp)
     145:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
     149:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	// Loop over all entries
	for(unsigned int i = 0; i < number; i++) {
		entry = &entries[i];

		// Is this entry usable?
		if(entry->name[0] != 0xE5 && entry->name[0] != 0x00) {
     150:	0f b6 03             	movzbl (%ebx),%eax
     153:	84 c0                	test   %al,%al
     155:	0f 84 c5 00 00 00    	je     220 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x13c>
     15b:	3c e5                	cmp    $0xe5,%al
     15d:	0f 84 bd 00 00 00    	je     220 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x13c>
			// Clear state
			item = NULL;

			// Long name
			if((entry->attributes & FAT_ATTR_LFN) == FAT_ATTR_LFN) {
     163:	0f b6 53 0b          	movzbl 0xb(%ebx),%edx
     167:	89 d1                	mov    %edx,%ecx
     169:	83 e1 0f             	and    $0xf,%ecx
     16c:	83 f9 0f             	cmp    $0xf,%ecx
     16f:	0f 84 cb 01 00 00    	je     340 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x25c>
					}

					// Copy checksum
					longname_checksum = ln->checksum;
				}
			} else if(entry->attributes & FAT_ATTR_DIRECTORY) { // directory
     175:	f6 c2 10             	test   $0x10,%dl
     178:	0f 84 b2 00 00 00    	je     230 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x14c>
		/*
		 * Extracts the 8.3 filename for a directory entry, and formats it as a 14-byte
		 * character string.
		 */
		static char* dirent_get_8_3_name(fat_dirent_t *d) {
			char *buf = (char *) kmalloc(16);
     17e:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
     185:	e8 fc ff ff ff       	call   186 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0xa2>
     18a:	89 c7                	mov    %eax,%edi
			memclr(buf, 16);
     18c:	b8 10 00 00 00       	mov    $0x10,%eax
     191:	89 44 24 04          	mov    %eax,0x4(%esp)
     195:	89 3c 24             	mov    %edi,(%esp)
     198:	e8 fc ff ff ff       	call   199 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0xb5>

			unsigned int c = 0;
     19d:	31 c9                	xor    %ecx,%ecx
     19f:	90                   	nop

			// Copy filename
			for(int i = 0; i < 8; i++) {
				if(d->name[i] != ' ') {
     1a0:	0f b6 04 0b          	movzbl (%ebx,%ecx,1),%eax
     1a4:	3c 20                	cmp    $0x20,%al
     1a6:	74 09                	je     1b1 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0xcd>
					buf[c++] = d->name[i];
     1a8:	88 04 0f             	mov    %al,(%edi,%ecx,1)
     1ab:	41                   	inc    %ecx
			memclr(buf, 16);

			unsigned int c = 0;

			// Copy filename
			for(int i = 0; i < 8; i++) {
     1ac:	83 f9 08             	cmp    $0x8,%ecx
     1af:	75 ef                	jne    1a0 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0xbc>
					break;
				}
			}

			// Dot
			if(!(d->attributes & FAT_ATTR_DIRECTORY)) {
     1b1:	f6 43 0b 10          	testb  $0x10,0xb(%ebx)
     1b5:	75 05                	jne    1bc <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0xd8>
				buf[c++] = '.';
     1b7:	c6 04 0f 2e          	movb   $0x2e,(%edi,%ecx,1)
     1bb:	41                   	inc    %ecx
		 */
		static char* dirent_get_8_3_name(fat_dirent_t *d) {
			char *buf = (char *) kmalloc(16);
			memclr(buf, 16);

			unsigned int c = 0;
     1bc:	31 d2                	xor    %edx,%edx
				buf[c++] = '.';
			}

			// Extension
			for(int i = 0; i < 3; i++) {
				if(d->ext[i] != ' ') {
     1be:	0f b6 44 13 08       	movzbl 0x8(%ebx,%edx,1),%eax
     1c3:	3c 20                	cmp    $0x20,%al
     1c5:	0f 84 15 03 00 00    	je     4e0 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x3fc>
			if(!(d->attributes & FAT_ATTR_DIRECTORY)) {
				buf[c++] = '.';
			}

			// Extension
			for(int i = 0; i < 3; i++) {
     1cb:	42                   	inc    %edx
				if(d->ext[i] != ' ') {
					buf[c++] = d->ext[i];
     1cc:	88 04 0f             	mov    %al,(%edi,%ecx,1)
     1cf:	41                   	inc    %ecx
			if(!(d->attributes & FAT_ATTR_DIRECTORY)) {
				buf[c++] = '.';
			}

			// Extension
			for(int i = 0; i < 3; i++) {
     1d0:	83 fa 03             	cmp    $0x3,%edx
     1d3:	75 e9                	jne    1be <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0xda>
				char *name = fs_fat32::dirent_get_8_3_name(entry);

				// Ignore dot and dotdot
				if(strcmp(".", name) && strcmp("..", name)) {
     1d5:	89 7c 24 04          	mov    %edi,0x4(%esp)
     1d9:	c7 04 24 d0 0e 00 00 	movl   $0xed0,(%esp)
     1e0:	e8 fc ff ff ff       	call   1e1 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0xfd>
     1e5:	85 c0                	test   %eax,%eax
     1e7:	0f 85 13 02 00 00    	jne    400 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x31c>
     1ed:	8d 76 00             	lea    0x0(%esi),%esi
		uint16_t name2[6]; // characters 6-11
		uint16_t name3[2]; // characters 12-13
	} longname_buffer[0x3F];

	// Loop over all entries
	for(unsigned int i = 0; i < number; i++) {
     1f0:	46                   	inc    %esi
     1f1:	83 c3 20             	add    $0x20,%ebx
     1f4:	3b b5 74 f9 ff ff    	cmp    -0x68c(%ebp),%esi
     1fa:	0f 85 50 ff ff ff    	jne    150 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x6c>
		}
	}

	// Perform some cleanup after the conversion finishes.
	done: ;
}
     200:	8b 55 e4             	mov    -0x1c(%ebp),%edx
     203:	33 15 00 00 00 00    	xor    0x0,%edx
     209:	0f 85 d2 03 00 00    	jne    5e1 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x4fd>
     20f:	81 c4 ac 06 00 00    	add    $0x6ac,%esp
     215:	5b                   	pop    %ebx
     216:	5e                   	pop    %esi
     217:	5f                   	pop    %edi
     218:	5d                   	pop    %ebp
     219:	c3                   	ret    
     21a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			if(item) {
				item->is_hidden = (entry->attributes & FAT_ATTR_HIDDEN);
				item->is_system = (entry->attributes & FAT_ATTR_SYSTEM);
				item->is_readonly = (entry->attributes & FAT_ATTR_READ_ONLY);
			}
		} else if(entry->name[0] == 0x00) {
     220:	84 c0                	test   %al,%al
     222:	75 cc                	jne    1f0 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x10c>
     224:	eb da                	jmp    200 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x11c>
     226:	8d 76 00             	lea    0x0(%esi),%esi
     229:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
					// Add directory as child
					list_add(root->children, dir);
				}
			} else { // regular file
				// Allocate a file object
				fs_file_t *file = hal_vfs_allocate_file(root);
     230:	8b 95 68 f9 ff ff    	mov    -0x698(%ebp),%edx
     236:	89 14 24             	mov    %edx,(%esp)
     239:	e8 fc ff ff ff       	call   23a <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x156>
				unsigned int c = 0;

				// Handle long name
				if(foundLongName) {
     23e:	80 bd 70 f9 ff ff 00 	cmpb   $0x0,-0x690(%ebp)
					// Add directory as child
					list_add(root->children, dir);
				}
			} else { // regular file
				// Allocate a file object
				fs_file_t *file = hal_vfs_allocate_file(root);
     245:	89 85 6c f9 ff ff    	mov    %eax,-0x694(%ebp)
				unsigned int c = 0;

				// Handle long name
				if(foundLongName) {
     24b:	0f 85 ff 01 00 00    	jne    450 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x36c>

					longname_checksum = longname_num = 0;
					foundLongName = false;
				} else {
					// Lowercase basename?
					if(entry->nt_reserved & 0x08) {
     251:	0f b6 7b 0c          	movzbl 0xc(%ebx),%edi
     255:	f7 c7 08 00 00 00    	test   $0x8,%edi
     25b:	74 1c                	je     279 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x195>
     25d:	31 c9                	xor    %ecx,%ecx
     25f:	90                   	nop
						for(c = 0; c < 8; c++) {
							entry->name[c] = tolower(entry->name[c]);
     260:	0f b6 04 0b          	movzbl (%ebx,%ecx,1),%eax
     264:	88 c2                	mov    %al,%dl
     266:	80 ea 41             	sub    $0x41,%dl
     269:	80 fa 19             	cmp    $0x19,%dl
     26c:	77 02                	ja     270 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x18c>
     26e:	04 20                	add    $0x20,%al
     270:	88 04 0b             	mov    %al,(%ebx,%ecx,1)
					longname_checksum = longname_num = 0;
					foundLongName = false;
				} else {
					// Lowercase basename?
					if(entry->nt_reserved & 0x08) {
						for(c = 0; c < 8; c++) {
     273:	41                   	inc    %ecx
     274:	83 f9 08             	cmp    $0x8,%ecx
     277:	75 e7                	jne    260 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x17c>
							entry->name[c] = tolower(entry->name[c]);
						}
					} 

					// Lowercase extension?
					if(entry->nt_reserved & 0x10) {
     279:	83 e7 10             	and    $0x10,%edi
     27c:	74 1d                	je     29b <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x1b7>
     27e:	31 c9                	xor    %ecx,%ecx
						for(c = 0; c < 3; c++) {
							entry->ext[c] = tolower(entry->ext[c]);
     280:	0f b6 44 0b 08       	movzbl 0x8(%ebx,%ecx,1),%eax
     285:	88 c2                	mov    %al,%dl
     287:	80 ea 41             	sub    $0x41,%dl
     28a:	80 fa 19             	cmp    $0x19,%dl
     28d:	77 02                	ja     291 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x1ad>
     28f:	04 20                	add    $0x20,%al
     291:	88 44 0b 08          	mov    %al,0x8(%ebx,%ecx,1)
						}
					} 

					// Lowercase extension?
					if(entry->nt_reserved & 0x10) {
						for(c = 0; c < 3; c++) {
     295:	41                   	inc    %ecx
     296:	83 f9 03             	cmp    $0x3,%ecx
     299:	75 e5                	jne    280 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x19c>
		/*
		 * Extracts the 8.3 filename for a directory entry, and formats it as a 14-byte
		 * character string.
		 */
		static char* dirent_get_8_3_name(fat_dirent_t *d) {
			char *buf = (char *) kmalloc(16);
     29b:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
     2a2:	e8 fc ff ff ff       	call   2a3 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x1bf>
			memclr(buf, 16);
     2a7:	b9 10 00 00 00       	mov    $0x10,%ecx
     2ac:	89 4c 24 04          	mov    %ecx,0x4(%esp)
		/*
		 * Extracts the 8.3 filename for a directory entry, and formats it as a 14-byte
		 * character string.
		 */
		static char* dirent_get_8_3_name(fat_dirent_t *d) {
			char *buf = (char *) kmalloc(16);
     2b0:	89 c7                	mov    %eax,%edi
			memclr(buf, 16);
     2b2:	89 04 24             	mov    %eax,(%esp)
     2b5:	e8 fc ff ff ff       	call   2b6 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x1d2>

			unsigned int c = 0;
     2ba:	31 c9                	xor    %ecx,%ecx
     2bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

			// Copy filename
			for(int i = 0; i < 8; i++) {
				if(d->name[i] != ' ') {
     2c0:	0f b6 04 0b          	movzbl (%ebx,%ecx,1),%eax
     2c4:	3c 20                	cmp    $0x20,%al
     2c6:	74 09                	je     2d1 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x1ed>
					buf[c++] = d->name[i];
     2c8:	88 04 0f             	mov    %al,(%edi,%ecx,1)
     2cb:	41                   	inc    %ecx
			memclr(buf, 16);

			unsigned int c = 0;

			// Copy filename
			for(int i = 0; i < 8; i++) {
     2cc:	83 f9 08             	cmp    $0x8,%ecx
     2cf:	75 ef                	jne    2c0 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x1dc>
					break;
				}
			}

			// Dot
			if(!(d->attributes & FAT_ATTR_DIRECTORY)) {
     2d1:	f6 43 0b 10          	testb  $0x10,0xb(%ebx)
     2d5:	75 05                	jne    2dc <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x1f8>
				buf[c++] = '.';
     2d7:	c6 04 0f 2e          	movb   $0x2e,(%edi,%ecx,1)
     2db:	41                   	inc    %ecx
		 */
		static char* dirent_get_8_3_name(fat_dirent_t *d) {
			char *buf = (char *) kmalloc(16);
			memclr(buf, 16);

			unsigned int c = 0;
     2dc:	31 d2                	xor    %edx,%edx
				buf[c++] = '.';
			}

			// Extension
			for(int i = 0; i < 3; i++) {
				if(d->ext[i] != ' ') {
     2de:	0f b6 44 13 08       	movzbl 0x8(%ebx,%edx,1),%eax
     2e3:	3c 20                	cmp    $0x20,%al
     2e5:	0f 84 05 02 00 00    	je     4f0 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x40c>
			if(!(d->attributes & FAT_ATTR_DIRECTORY)) {
				buf[c++] = '.';
			}

			// Extension
			for(int i = 0; i < 3; i++) {
     2eb:	42                   	inc    %edx
				if(d->ext[i] != ' ') {
					buf[c++] = d->ext[i];
     2ec:	88 04 0f             	mov    %al,(%edi,%ecx,1)
     2ef:	41                   	inc    %ecx
			if(!(d->attributes & FAT_ATTR_DIRECTORY)) {
				buf[c++] = '.';
			}

			// Extension
			for(int i = 0; i < 3; i++) {
     2f0:	83 fa 03             	cmp    $0x3,%edx
     2f3:	75 e9                	jne    2de <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x1fa>
						}
					}

					// Regular shortname
					char *name = fs_fat32::dirent_get_8_3_name(entry);
					file->i.name = name;
     2f5:	8b 85 6c f9 ff ff    	mov    -0x694(%ebp),%eax
     2fb:	89 78 04             	mov    %edi,0x4(%eax)
				}

				// Save the item
				item = &file->i;
     2fe:	8b bd 6c f9 ff ff    	mov    -0x694(%ebp),%edi
     304:	c6 85 70 f9 ff ff 00 	movb   $0x0,-0x690(%ebp)
			}

			// Set flags
			if(item) {
     30b:	85 ff                	test   %edi,%edi
     30d:	0f 84 dd fe ff ff    	je     1f0 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x10c>
				item->is_hidden = (entry->attributes & FAT_ATTR_HIDDEN);
     313:	f6 43 0b 02          	testb  $0x2,0xb(%ebx)
     317:	0f 95 47 0e          	setne  0xe(%edi)
				item->is_system = (entry->attributes & FAT_ATTR_SYSTEM);
     31b:	f6 43 0b 04          	testb  $0x4,0xb(%ebx)
     31f:	0f 95 47 0f          	setne  0xf(%edi)
				item->is_readonly = (entry->attributes & FAT_ATTR_READ_ONLY);
     323:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
     327:	83 e0 01             	and    $0x1,%eax
     32a:	88 47 10             	mov    %al,0x10(%edi)
     32d:	e9 be fe ff ff       	jmp    1f0 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x10c>
     332:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
     339:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
			if((entry->attributes & FAT_ATTR_LFN) == FAT_ATTR_LFN) {
				// Get longname entry
				fat_longname_dirent_t *ln = (fat_longname_dirent_t *) entry;

				// Ignore invalid longname entries
				if(ln->type == 0) {
     340:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
     344:	0f 85 a6 fe ff ff    	jne    1f0 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x10c>
					foundLongName = true;

					unsigned int longname_offset = (ln->order & 0x3F) - 1;
     34a:	0f b6 c0             	movzbl %al,%eax
     34d:	89 c1                	mov    %eax,%ecx
     34f:	83 e1 3f             	and    $0x3f,%ecx

					// Last entry?
					if(ln->order & 0x40) {
						longname_num = longname_offset + 1;
     352:	a8 40                	test   $0x40,%al

				// Ignore invalid longname entries
				if(ln->type == 0) {
					foundLongName = true;

					unsigned int longname_offset = (ln->order & 0x3F) - 1;
     354:	8d 51 ff             	lea    -0x1(%ecx),%edx

					// Copy strings
					unsigned int c = 0;

					for(c = 0; c < 5; c++){
						longname_buffer[longname_offset].name1[c] = ln->name1[c];
     357:	8d 04 52             	lea    (%edx,%edx,2),%eax

					unsigned int longname_offset = (ln->order & 0x3F) - 1;

					// Last entry?
					if(ln->order & 0x40) {
						longname_num = longname_offset + 1;
     35a:	0f 44 8d 64 f9 ff ff 	cmove  -0x69c(%ebp),%ecx

					// Copy strings
					unsigned int c = 0;

					for(c = 0; c < 5; c++){
						longname_buffer[longname_offset].name1[c] = ln->name1[c];
     361:	8d 3c 82             	lea    (%edx,%eax,4),%edi
     364:	0f b7 53 01          	movzwl 0x1(%ebx),%edx
     368:	8d 45 e8             	lea    -0x18(%ebp),%eax

					unsigned int longname_offset = (ln->order & 0x3F) - 1;

					// Last entry?
					if(ln->order & 0x40) {
						longname_num = longname_offset + 1;
     36b:	89 8d 64 f9 ff ff    	mov    %ecx,-0x69c(%ebp)

					// Copy strings
					unsigned int c = 0;

					for(c = 0; c < 5; c++){
						longname_buffer[longname_offset].name1[c] = ln->name1[c];
     371:	8d 0c 3f             	lea    (%edi,%edi,1),%ecx
     374:	01 c8                	add    %ecx,%eax
     376:	66 89 90 96 f9 ff ff 	mov    %dx,-0x66a(%eax)
     37d:	0f b7 53 03          	movzwl 0x3(%ebx),%edx
     381:	66 89 90 98 f9 ff ff 	mov    %dx,-0x668(%eax)
     388:	0f b7 53 05          	movzwl 0x5(%ebx),%edx
     38c:	66 89 90 9a f9 ff ff 	mov    %dx,-0x666(%eax)
     393:	0f b7 53 07          	movzwl 0x7(%ebx),%edx
     397:	66 89 90 9c f9 ff ff 	mov    %dx,-0x664(%eax)
     39e:	0f b7 53 09          	movzwl 0x9(%ebx),%edx
     3a2:	66 89 90 9e f9 ff ff 	mov    %dx,-0x662(%eax)

/*
 * Converts FAT32-style directory entries into fat_file_t or fat_directory_t
 * objects, and adds them as children of the specified directory.
 */
void fs_fat32::processFATDirEnt(fat_dirent_t *entries, unsigned int number, fs_directory_t *root) {
     3a9:	8d 95 7e f9 ff ff    	lea    -0x682(%ebp),%edx

					// Copy strings
					unsigned int c = 0;

					for(c = 0; c < 5; c++){
						longname_buffer[longname_offset].name1[c] = ln->name1[c];
     3af:	31 c0                	xor    %eax,%eax

/*
 * Converts FAT32-style directory entries into fat_file_t or fat_directory_t
 * objects, and adds them as children of the specified directory.
 */
void fs_fat32::processFATDirEnt(fat_dirent_t *entries, unsigned int number, fs_directory_t *root) {
     3b1:	01 d1                	add    %edx,%ecx
     3b3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     3b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
					for(c = 0; c < 5; c++){
						longname_buffer[longname_offset].name1[c] = ln->name1[c];
					}

					for(c = 0; c < 6; c++){
						longname_buffer[longname_offset].name2[c] = ln->name2[c];
     3c0:	0f b7 54 43 0e       	movzwl 0xe(%ebx,%eax,2),%edx
     3c5:	66 89 54 41 0a       	mov    %dx,0xa(%ecx,%eax,2)

					for(c = 0; c < 5; c++){
						longname_buffer[longname_offset].name1[c] = ln->name1[c];
					}

					for(c = 0; c < 6; c++){
     3ca:	40                   	inc    %eax
     3cb:	83 f8 06             	cmp    $0x6,%eax
     3ce:	75 f0                	jne    3c0 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x2dc>
						longname_buffer[longname_offset].name2[c] = ln->name2[c];
					}

					for(c = 0; c < 2; c++){
						longname_buffer[longname_offset].name3[c] = ln->name3[c];
     3d0:	0f b7 53 1c          	movzwl 0x1c(%ebx),%edx
     3d4:	8d 44 7d e8          	lea    -0x18(%ebp,%edi,2),%eax
					}

					// Copy checksum
					longname_checksum = ln->checksum;
     3d8:	0f b6 4b 0d          	movzbl 0xd(%ebx),%ecx
				// Get longname entry
				fat_longname_dirent_t *ln = (fat_longname_dirent_t *) entry;

				// Ignore invalid longname entries
				if(ln->type == 0) {
					foundLongName = true;
     3dc:	c6 85 70 f9 ff ff 01 	movb   $0x1,-0x690(%ebp)
					for(c = 0; c < 6; c++){
						longname_buffer[longname_offset].name2[c] = ln->name2[c];
					}

					for(c = 0; c < 2; c++){
						longname_buffer[longname_offset].name3[c] = ln->name3[c];
     3e3:	66 89 90 ac f9 ff ff 	mov    %dx,-0x654(%eax)
     3ea:	0f b7 53 1e          	movzwl 0x1e(%ebx),%edx
					}

					// Copy checksum
					longname_checksum = ln->checksum;
     3ee:	88 8d 60 f9 ff ff    	mov    %cl,-0x6a0(%ebp)
					for(c = 0; c < 6; c++){
						longname_buffer[longname_offset].name2[c] = ln->name2[c];
					}

					for(c = 0; c < 2; c++){
						longname_buffer[longname_offset].name3[c] = ln->name3[c];
     3f4:	66 89 90 ae f9 ff ff 	mov    %dx,-0x652(%eax)
     3fb:	e9 f0 fd ff ff       	jmp    1f0 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x10c>
				}
			} else if(entry->attributes & FAT_ATTR_DIRECTORY) { // directory
				char *name = fs_fat32::dirent_get_8_3_name(entry);

				// Ignore dot and dotdot
				if(strcmp(".", name) && strcmp("..", name)) {
     400:	89 7c 24 04          	mov    %edi,0x4(%esp)
     404:	c7 04 24 d2 0e 00 00 	movl   $0xed2,(%esp)
     40b:	e8 fc ff ff ff       	call   40c <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x328>
     410:	85 c0                	test   %eax,%eax
     412:	0f 84 d8 fd ff ff    	je     1f0 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x10c>
					fs_directory_t *dir = hal_vfs_allocate_directory(true);
     418:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
     41f:	e8 fc ff ff ff       	call   420 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x33c>
					dir->i.name = name;
					dir->parent = root->i.handle;
     424:	8b 8d 68 f9 ff ff    	mov    -0x698(%ebp),%ecx
     42a:	8b 51 14             	mov    0x14(%ecx),%edx
				char *name = fs_fat32::dirent_get_8_3_name(entry);

				// Ignore dot and dotdot
				if(strcmp(".", name) && strcmp("..", name)) {
					fs_directory_t *dir = hal_vfs_allocate_directory(true);
					dir->i.name = name;
     42d:	89 78 04             	mov    %edi,0x4(%eax)
					dir->parent = root->i.handle;
					item = &dir->i;
     430:	89 c7                	mov    %eax,%edi

				// Ignore dot and dotdot
				if(strcmp(".", name) && strcmp("..", name)) {
					fs_directory_t *dir = hal_vfs_allocate_directory(true);
					dir->i.name = name;
					dir->parent = root->i.handle;
     432:	89 50 18             	mov    %edx,0x18(%eax)
					item = &dir->i;

					// Add directory as child
					list_add(root->children, dir);
     435:	89 44 24 04          	mov    %eax,0x4(%esp)
     439:	8b 41 1c             	mov    0x1c(%ecx),%eax
     43c:	89 04 24             	mov    %eax,(%esp)
     43f:	e8 fc ff ff ff       	call   440 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x35c>
     444:	e9 c2 fe ff ff       	jmp    30b <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x227>
     449:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				unsigned int c = 0;

				// Handle long name
				if(foundLongName) {
					// Allocate memory
					char *newName = (char *) kmalloc((longname_num * 13) + 1);
     450:	8b 8d 64 f9 ff ff    	mov    -0x69c(%ebp),%ecx

/*
 * Converts FAT32-style directory entries into fat_file_t or fat_directory_t
 * objects, and adds them as children of the specified directory.
 */
void fs_fat32::processFATDirEnt(fat_dirent_t *entries, unsigned int number, fs_directory_t *root) {
     456:	8d 7b 0b             	lea    0xb(%ebx),%edi
				unsigned int c = 0;

				// Handle long name
				if(foundLongName) {
					// Allocate memory
					char *newName = (char *) kmalloc((longname_num * 13) + 1);
     459:	8d 04 49             	lea    (%ecx,%ecx,2),%eax
     45c:	8d 44 81 01          	lea    0x1(%ecx,%eax,4),%eax
     460:	89 04 24             	mov    %eax,(%esp)
     463:	e8 fc ff ff ff       	call   464 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x380>
					unsigned int newNameLen = 0;

					// Copy the individual characters
					if(longname_checksum == this->lfnCheckSum((unsigned char *) &entry->name)) {
     468:	89 da                	mov    %ebx,%edx
	uint16_t FcbNameLen;
	uint8_t sum = 0;

	for(FcbNameLen = 11; FcbNameLen != 0; FcbNameLen--) {
		// NOTE: The operation is an unsigned char rotate right
		sum = ((sum & 1) ? 0x80 : 0) + (sum >> 1) + *shortName++;
     46a:	31 c9                	xor    %ecx,%ecx
				unsigned int c = 0;

				// Handle long name
				if(foundLongName) {
					// Allocate memory
					char *newName = (char *) kmalloc((longname_num * 13) + 1);
     46c:	89 85 70 f9 ff ff    	mov    %eax,-0x690(%ebp)
	uint16_t FcbNameLen;
	uint8_t sum = 0;

	for(FcbNameLen = 11; FcbNameLen != 0; FcbNameLen--) {
		// NOTE: The operation is an unsigned char rotate right
		sum = ((sum & 1) ? 0x80 : 0) + (sum >> 1) + *shortName++;
     472:	31 c0                	xor    %eax,%eax
     474:	eb 1b                	jmp    491 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x3ad>
     476:	8d 76 00             	lea    0x0(%esi),%esi
     479:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
     480:	0f b6 c8             	movzbl %al,%ecx
     483:	89 c8                	mov    %ecx,%eax
     485:	83 e0 01             	and    $0x1,%eax
     488:	83 f8 01             	cmp    $0x1,%eax
     48b:	19 c0                	sbb    %eax,%eax
     48d:	f6 d0                	not    %al
     48f:	24 80                	and    $0x80,%al
     491:	02 02                	add    (%edx),%al
     493:	42                   	inc    %edx
     494:	d1 f9                	sar    %ecx
     496:	00 c8                	add    %cl,%al
 */
uint8_t fs_fat32::lfnCheckSum(unsigned char *shortName) {
	uint16_t FcbNameLen;
	uint8_t sum = 0;

	for(FcbNameLen = 11; FcbNameLen != 0; FcbNameLen--) {
     498:	39 fa                	cmp    %edi,%edx
     49a:	75 e4                	jne    480 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x39c>
					// Allocate memory
					char *newName = (char *) kmalloc((longname_num * 13) + 1);
					unsigned int newNameLen = 0;

					// Copy the individual characters
					if(longname_checksum == this->lfnCheckSum((unsigned char *) &entry->name)) {
     49c:	3a 85 60 f9 ff ff    	cmp    -0x6a0(%ebp),%al
     4a2:	74 5c                	je     500 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x41c>

						longname_done: ;
					}

					// Free old name and save new
					kfree(file->i.name);
     4a4:	8b 8d 6c f9 ff ff    	mov    -0x694(%ebp),%ecx
					file->i.name = newName;

					longname_checksum = longname_num = 0;
     4aa:	31 ff                	xor    %edi,%edi

						longname_done: ;
					}

					// Free old name and save new
					kfree(file->i.name);
     4ac:	8b 41 04             	mov    0x4(%ecx),%eax
     4af:	89 04 24             	mov    %eax,(%esp)
     4b2:	e8 fc ff ff ff       	call   4b3 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x3cf>
					file->i.name = newName;
     4b7:	8b 95 70 f9 ff ff    	mov    -0x690(%ebp),%edx
     4bd:	8b 85 6c f9 ff ff    	mov    -0x694(%ebp),%eax

					longname_checksum = longname_num = 0;
     4c3:	c6 85 60 f9 ff ff 00 	movb   $0x0,-0x6a0(%ebp)
     4ca:	89 bd 64 f9 ff ff    	mov    %edi,-0x69c(%ebp)
						longname_done: ;
					}

					// Free old name and save new
					kfree(file->i.name);
					file->i.name = newName;
     4d0:	89 50 04             	mov    %edx,0x4(%eax)
     4d3:	e9 26 fe ff ff       	jmp    2fe <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x21a>
     4d8:	90                   	nop
     4d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				if(d->ext[i] != ' ') {
					buf[c++] = d->ext[i];
				} else {
					buf[c] = 0;
     4e0:	c6 04 0f 00          	movb   $0x0,(%edi,%ecx,1)
     4e4:	e9 ec fc ff ff       	jmp    1d5 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0xf1>
     4e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
     4f0:	c6 04 0f 00          	movb   $0x0,(%edi,%ecx,1)
     4f4:	e9 fc fd ff ff       	jmp    2f5 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x211>
     4f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
					char *newName = (char *) kmalloc((longname_num * 13) + 1);
					unsigned int newNameLen = 0;

					// Copy the individual characters
					if(longname_checksum == this->lfnCheckSum((unsigned char *) &entry->name)) {
						for(unsigned int l = 0; l < longname_num; l++) {
     500:	8b 85 64 f9 ff ff    	mov    -0x69c(%ebp),%eax
     506:	85 c0                	test   %eax,%eax
     508:	74 9a                	je     4a4 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x3c0>
     50a:	89 b5 5c f9 ff ff    	mov    %esi,-0x6a4(%ebp)
     510:	8b b5 70 f9 ff ff    	mov    -0x690(%ebp),%esi
     516:	31 c0                	xor    %eax,%eax
     518:	89 85 60 f9 ff ff    	mov    %eax,-0x6a0(%ebp)
     51e:	8d 8d 7e f9 ff ff    	lea    -0x682(%ebp),%ecx
     524:	31 c0                	xor    %eax,%eax
	uint16_t FcbNameLen;
	uint8_t sum = 0;

	for(FcbNameLen = 11; FcbNameLen != 0; FcbNameLen--) {
		// NOTE: The operation is an unsigned char rotate right
		sum = ((sum & 1) ? 0x80 : 0) + (sum >> 1) + *shortName++;
     526:	31 d2                	xor    %edx,%edx
     528:	89 c7                	mov    %eax,%edi
					// Copy the individual characters
					if(longname_checksum == this->lfnCheckSum((unsigned char *) &entry->name)) {
						for(unsigned int l = 0; l < longname_num; l++) {
							// Copy characters
							for(c = 0; c < 5; c++){
								if(longname_buffer[l].name1[c]) {
     52a:	0f b7 04 51          	movzwl (%ecx,%edx,2),%eax
     52e:	85 c0                	test   %eax,%eax
     530:	74 5e                	je     590 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x4ac>

					// Copy the individual characters
					if(longname_checksum == this->lfnCheckSum((unsigned char *) &entry->name)) {
						for(unsigned int l = 0; l < longname_num; l++) {
							// Copy characters
							for(c = 0; c < 5; c++){
     532:	42                   	inc    %edx
								if(longname_buffer[l].name1[c]) {
									newName[newNameLen++] = longname_buffer[l].name1[c];
     533:	88 04 3e             	mov    %al,(%esi,%edi,1)
     536:	47                   	inc    %edi

					// Copy the individual characters
					if(longname_checksum == this->lfnCheckSum((unsigned char *) &entry->name)) {
						for(unsigned int l = 0; l < longname_num; l++) {
							// Copy characters
							for(c = 0; c < 5; c++){
     537:	83 fa 05             	cmp    $0x5,%edx
     53a:	75 ee                	jne    52a <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x446>
     53c:	31 d2                	xor    %edx,%edx
									goto longname_done;
								}
							}

							for(c = 0; c < 6; c++){
								if(longname_buffer[l].name2[c]) {
     53e:	0f b7 44 51 0a       	movzwl 0xa(%ecx,%edx,2),%eax
     543:	85 c0                	test   %eax,%eax
     545:	74 49                	je     590 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x4ac>
								} else {
									goto longname_done;
								}
							}

							for(c = 0; c < 6; c++){
     547:	42                   	inc    %edx
								if(longname_buffer[l].name2[c]) {
									newName[newNameLen++] = longname_buffer[l].name2[c];
     548:	88 04 3e             	mov    %al,(%esi,%edi,1)
     54b:	47                   	inc    %edi
								} else {
									goto longname_done;
								}
							}

							for(c = 0; c < 6; c++){
     54c:	83 fa 06             	cmp    $0x6,%edx
     54f:	75 ed                	jne    53e <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x45a>
									goto longname_done;
								}
							}

							for(c = 0; c < 2; c++){
								if(longname_buffer[l].name3[c]) {
     551:	0f b7 51 16          	movzwl 0x16(%ecx),%edx
     555:	89 f8                	mov    %edi,%eax
     557:	85 d2                	test   %edx,%edx
     559:	74 35                	je     590 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x4ac>
									newName[newNameLen++] = longname_buffer[l].name3[c];
     55b:	88 14 3e             	mov    %dl,(%esi,%edi,1)
									goto longname_done;
								}
							}

							for(c = 0; c < 2; c++){
								if(longname_buffer[l].name3[c]) {
     55e:	0f b7 51 18          	movzwl 0x18(%ecx),%edx
     562:	85 d2                	test   %edx,%edx
     564:	74 2a                	je     590 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x4ac>
					char *newName = (char *) kmalloc((longname_num * 13) + 1);
					unsigned int newNameLen = 0;

					// Copy the individual characters
					if(longname_checksum == this->lfnCheckSum((unsigned char *) &entry->name)) {
						for(unsigned int l = 0; l < longname_num; l++) {
     566:	ff 85 60 f9 ff ff    	incl   -0x6a0(%ebp)
								}
							}

							for(c = 0; c < 2; c++){
								if(longname_buffer[l].name3[c]) {
									newName[newNameLen++] = longname_buffer[l].name3[c];
     56c:	83 c0 02             	add    $0x2,%eax
					char *newName = (char *) kmalloc((longname_num * 13) + 1);
					unsigned int newNameLen = 0;

					// Copy the individual characters
					if(longname_checksum == this->lfnCheckSum((unsigned char *) &entry->name)) {
						for(unsigned int l = 0; l < longname_num; l++) {
     56f:	83 c1 1a             	add    $0x1a,%ecx
								}
							}

							for(c = 0; c < 2; c++){
								if(longname_buffer[l].name3[c]) {
									newName[newNameLen++] = longname_buffer[l].name3[c];
     572:	88 54 3e 01          	mov    %dl,0x1(%esi,%edi,1)
					char *newName = (char *) kmalloc((longname_num * 13) + 1);
					unsigned int newNameLen = 0;

					// Copy the individual characters
					if(longname_checksum == this->lfnCheckSum((unsigned char *) &entry->name)) {
						for(unsigned int l = 0; l < longname_num; l++) {
     576:	8b 95 64 f9 ff ff    	mov    -0x69c(%ebp),%edx
     57c:	39 95 60 f9 ff ff    	cmp    %edx,-0x6a0(%ebp)
     582:	75 a2                	jne    526 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x442>
     584:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     58a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi
     590:	8b b5 5c f9 ff ff    	mov    -0x6a4(%ebp),%esi
     596:	e9 09 ff ff ff       	jmp    4a4 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x3c0>
 * Converts FAT32-style directory entries into fat_file_t or fat_directory_t
 * objects, and adds them as children of the specified directory.
 */
void fs_fat32::processFATDirEnt(fat_dirent_t *entries, unsigned int number, fs_directory_t *root) {
	// Sanity checking
	ASSERT(root);
     59b:	b9 b9 0e 00 00       	mov    $0xeb9,%ecx
     5a0:	be b2 00 00 00       	mov    $0xb2,%esi
     5a5:	89 4c 24 08          	mov    %ecx,0x8(%esp)
     5a9:	89 74 24 04          	mov    %esi,0x4(%esp)
     5ad:	c7 04 24 be 0e 00 00 	movl   $0xebe,(%esp)
     5b4:	e8 fc ff ff ff       	call   5b5 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x4d1>
     5b9:	e9 59 fb ff ff       	jmp    117 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x33>
	ASSERT(entries);
     5be:	b8 c8 0e 00 00       	mov    $0xec8,%eax
     5c3:	ba b3 00 00 00       	mov    $0xb3,%edx
     5c8:	89 44 24 08          	mov    %eax,0x8(%esp)
     5cc:	89 54 24 04          	mov    %edx,0x4(%esp)
     5d0:	c7 04 24 be 0e 00 00 	movl   $0xebe,(%esp)
     5d7:	e8 fc ff ff ff       	call   5d8 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x4f4>
     5dc:	e9 3e fb ff ff       	jmp    11f <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x3b>
		}
	}

	// Perform some cleanup after the conversion finishes.
	done: ;
}
     5e1:	e8 fc ff ff ff       	call   5e2 <_ZN8fs_fat3216processFATDirEntEP12fat_dirent_tjP12fs_directory+0x4fe>
     5e6:	66 90                	xchg   %ax,%ax

000005e8 <_ZN8fs_fat3211lfnCheckSumEPh>:

/*
 * Calculates the checksum for a long name.
 */
uint8_t fs_fat32::lfnCheckSum(unsigned char *shortName) {
     5e8:	55                   	push   %ebp
	uint16_t FcbNameLen;
	uint8_t sum = 0;

	for(FcbNameLen = 11; FcbNameLen != 0; FcbNameLen--) {
		// NOTE: The operation is an unsigned char rotate right
		sum = ((sum & 1) ? 0x80 : 0) + (sum >> 1) + *shortName++;
     5e9:	31 c9                	xor    %ecx,%ecx
}

/*
 * Calculates the checksum for a long name.
 */
uint8_t fs_fat32::lfnCheckSum(unsigned char *shortName) {
     5eb:	89 e5                	mov    %esp,%ebp
     5ed:	53                   	push   %ebx
     5ee:	83 ec 14             	sub    $0x14,%esp
     5f1:	8b 55 0c             	mov    0xc(%ebp),%edx
     5f4:	a1 00 00 00 00       	mov    0x0,%eax
     5f9:	89 45 f4             	mov    %eax,-0xc(%ebp)
     5fc:	31 c0                	xor    %eax,%eax
     5fe:	8d 5a 0b             	lea    0xb(%edx),%ebx
     601:	eb 1e                	jmp    621 <_ZN8fs_fat3211lfnCheckSumEPh+0x39>
     603:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     609:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	uint16_t FcbNameLen;
	uint8_t sum = 0;

	for(FcbNameLen = 11; FcbNameLen != 0; FcbNameLen--) {
		// NOTE: The operation is an unsigned char rotate right
		sum = ((sum & 1) ? 0x80 : 0) + (sum >> 1) + *shortName++;
     610:	0f b6 c8             	movzbl %al,%ecx
     613:	89 c8                	mov    %ecx,%eax
     615:	83 e0 01             	and    $0x1,%eax
     618:	83 f8 01             	cmp    $0x1,%eax
     61b:	19 c0                	sbb    %eax,%eax
     61d:	f6 d0                	not    %al
     61f:	24 80                	and    $0x80,%al
     621:	02 02                	add    (%edx),%al
     623:	42                   	inc    %edx
     624:	d1 f9                	sar    %ecx
     626:	00 c8                	add    %cl,%al
 */
uint8_t fs_fat32::lfnCheckSum(unsigned char *shortName) {
	uint16_t FcbNameLen;
	uint8_t sum = 0;

	for(FcbNameLen = 11; FcbNameLen != 0; FcbNameLen--) {
     628:	39 da                	cmp    %ebx,%edx
     62a:	75 e4                	jne    610 <_ZN8fs_fat3211lfnCheckSumEPh+0x28>
		// NOTE: The operation is an unsigned char rotate right
		sum = ((sum & 1) ? 0x80 : 0) + (sum >> 1) + *shortName++;
	}

	return sum;
}
     62c:	8b 55 f4             	mov    -0xc(%ebp),%edx
     62f:	33 15 00 00 00 00    	xor    0x0,%edx
     635:	75 06                	jne    63d <_ZN8fs_fat3211lfnCheckSumEPh+0x55>
     637:	83 c4 14             	add    $0x14,%esp
     63a:	5b                   	pop    %ebx
     63b:	5d                   	pop    %ebp
     63c:	c3                   	ret    
     63d:	e8 fc ff ff ff       	call   63e <_ZN8fs_fat3211lfnCheckSumEPh+0x56>
     642:	66 90                	xchg   %ax,%ax

00000644 <_ZN8fs_fat3224fatEntryOffsetForClusterEj>:
 * Calculates a cluster's offset into the FAT. The returned structure indicates
 * the sector to read, and the dword offset into that sector. In other words,
 * if the sector is read as an array of bytes, the offset must be multiplied
 * by four.
 */
fat32_secoff_t fs_fat32::fatEntryOffsetForCluster(unsigned int cluster) {
     644:	55                   	push   %ebp
     645:	89 e5                	mov    %esp,%ebp
     647:	53                   	push   %ebx
     648:	83 ec 14             	sub    $0x14,%esp
     64b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
     64e:	8b 45 10             	mov    0x10(%ebp),%eax
     651:	8b 15 00 00 00 00    	mov    0x0,%edx
     657:	89 55 f4             	mov    %edx,-0xc(%ebp)
     65a:	31 d2                	xor    %edx,%edx
	fat32_secoff_t offset;

	// Determine size of FAT and normalise cluster
	offset.sector = bpb.reserved_sector_count + (cluster / cluster_size);
     65c:	31 d2                	xor    %edx,%edx
 * Calculates a cluster's offset into the FAT. The returned structure indicates
 * the sector to read, and the dword offset into that sector. In other words,
 * if the sector is read as an array of bytes, the offset must be multiplied
 * by four.
 */
fat32_secoff_t fs_fat32::fatEntryOffsetForCluster(unsigned int cluster) {
     65e:	8b 4d 08             	mov    0x8(%ebp),%ecx
	fat32_secoff_t offset;

	// Determine size of FAT and normalise cluster
	offset.sector = bpb.reserved_sector_count + (cluster / cluster_size);
     661:	f7 b3 7c 02 00 00    	divl   0x27c(%ebx)
     667:	0f b7 5b 1e          	movzwl 0x1e(%ebx),%ebx
	offset.offset = cluster % cluster_size;
     66b:	89 51 04             	mov    %edx,0x4(%ecx)
 */
fat32_secoff_t fs_fat32::fatEntryOffsetForCluster(unsigned int cluster) {
	fat32_secoff_t offset;

	// Determine size of FAT and normalise cluster
	offset.sector = bpb.reserved_sector_count + (cluster / cluster_size);
     66e:	01 d8                	add    %ebx,%eax
	offset.offset = cluster % cluster_size;

	return offset;
}
     670:	8b 55 f4             	mov    -0xc(%ebp),%edx
     673:	33 15 00 00 00 00    	xor    0x0,%edx
 */
fat32_secoff_t fs_fat32::fatEntryOffsetForCluster(unsigned int cluster) {
	fat32_secoff_t offset;

	// Determine size of FAT and normalise cluster
	offset.sector = bpb.reserved_sector_count + (cluster / cluster_size);
     679:	89 01                	mov    %eax,(%ecx)
	offset.offset = cluster % cluster_size;

	return offset;
}
     67b:	89 c8                	mov    %ecx,%eax
     67d:	75 08                	jne    687 <_ZN8fs_fat3224fatEntryOffsetForClusterEj+0x43>
     67f:	83 c4 14             	add    $0x14,%esp
     682:	5b                   	pop    %ebx
     683:	5d                   	pop    %ebp
     684:	c2 04 00             	ret    $0x4
     687:	e8 fc ff ff ff       	call   688 <_ZN8fs_fat3224fatEntryOffsetForClusterEj+0x44>

0000068c <_ZN8fs_fat3222clusterChainForClusterEj>:
 * Follows the cluster chain to find all clusters on which the specified
 * starting cluster has data. This *can* be slow.
 *
 * Note that the array returned is terminated by FAT32_END_CHAIN.
 */
unsigned int *fs_fat32::clusterChainForCluster(unsigned int cluster) {
     68c:	55                   	push   %ebp
     68d:	89 e5                	mov    %esp,%ebp
     68f:	57                   	push   %edi
     690:	56                   	push   %esi
     691:	53                   	push   %ebx
     692:	83 ec 4c             	sub    $0x4c,%esp
     695:	8b 75 0c             	mov    0xc(%ebp),%esi
     698:	a1 00 00 00 00       	mov    0x0,%eax
     69d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
     6a0:	31 c0                	xor    %eax,%eax
     6a2:	8b 5d 08             	mov    0x8(%ebp),%ebx
	unsigned int chain_len = 32;
	unsigned int chain_offset = 0;
	unsigned int *chain = (unsigned int *) kmalloc(sizeof(unsigned int) * chain_len);
     6a5:	c7 04 24 80 00 00 00 	movl   $0x80,(%esp)
     6ac:	e8 fc ff ff ff       	call   6ad <_ZN8fs_fat3222clusterChainForClusterEj+0x21>
	unsigned int err;

	fat32_secoff_t off;

	// Guard against broken FS implementations
	if(cluster == 0) {
     6b1:	85 f6                	test   %esi,%esi
 * Note that the array returned is terminated by FAT32_END_CHAIN.
 */
unsigned int *fs_fat32::clusterChainForCluster(unsigned int cluster) {
	unsigned int chain_len = 32;
	unsigned int chain_offset = 0;
	unsigned int *chain = (unsigned int *) kmalloc(sizeof(unsigned int) * chain_len);
     6b3:	89 c7                	mov    %eax,%edi
	unsigned int err;

	fat32_secoff_t off;

	// Guard against broken FS implementations
	if(cluster == 0) {
     6b5:	0f 84 f5 00 00 00    	je     7b0 <_ZN8fs_fat3222clusterChainForClusterEj+0x124>
	// Place the initial cluster as the first entry in the chain.
	chain[chain_offset++] = cluster;

	// Repeat until the end is reached (marked by FAT32_END_CHAIN)
	unsigned int nextCluster = cluster;
	while(nextCluster != FAT32_END_CHAIN) {
     6bb:	81 fe f8 ff ff 0f    	cmp    $0xffffff8,%esi
     6c1:	89 f2                	mov    %esi,%edx
	if(cluster == 0) {
		cluster = 2;
	}

	// Place the initial cluster as the first entry in the chain.
	chain[chain_offset++] = cluster;
     6c3:	89 30                	mov    %esi,(%eax)

	// Repeat until the end is reached (marked by FAT32_END_CHAIN)
	unsigned int nextCluster = cluster;
	while(nextCluster != FAT32_END_CHAIN) {
     6c5:	0f 84 c5 00 00 00    	je     790 <_ZN8fs_fat3222clusterChainForClusterEj+0x104>
 * Follows the cluster chain to find all clusters on which the specified
 * starting cluster has data. This *can* be slow.
 *
 * Note that the array returned is terminated by FAT32_END_CHAIN.
 */
unsigned int *fs_fat32::clusterChainForCluster(unsigned int cluster) {
     6cb:	be 01 00 00 00       	mov    $0x1,%esi
     6d0:	89 d1                	mov    %edx,%ecx
     6d2:	c7 45 cc 20 00 00 00 	movl   $0x20,-0x34(%ebp)
     6d9:	eb 15                	jmp    6f0 <_ZN8fs_fat3222clusterChainForClusterEj+0x64>
     6db:	90                   	nop
     6dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			chain_len += 32;
			chain = (unsigned int *) krealloc(chain, sizeof(unsigned int) * chain_len);
		}

		// Write into chain array
		chain[chain_offset++] = nextCluster & FAT32_MASK;
     6e0:	89 0c b7             	mov    %ecx,(%edi,%esi,4)
     6e3:	46                   	inc    %esi
	// Place the initial cluster as the first entry in the chain.
	chain[chain_offset++] = cluster;

	// Repeat until the end is reached (marked by FAT32_END_CHAIN)
	unsigned int nextCluster = cluster;
	while(nextCluster != FAT32_END_CHAIN) {
     6e4:	81 f9 f8 ff ff 0f    	cmp    $0xffffff8,%ecx
     6ea:	0f 84 a0 00 00 00    	je     790 <_ZN8fs_fat3222clusterChainForClusterEj+0x104>
 */
fat32_secoff_t fs_fat32::fatEntryOffsetForCluster(unsigned int cluster) {
	fat32_secoff_t offset;

	// Determine size of FAT and normalise cluster
	offset.sector = bpb.reserved_sector_count + (cluster / cluster_size);
     6f0:	89 c8                	mov    %ecx,%eax
     6f2:	31 d2                	xor    %edx,%edx
     6f4:	f7 b3 7c 02 00 00    	divl   0x27c(%ebx)
     6fa:	89 55 d0             	mov    %edx,-0x30(%ebp)
     6fd:	0f b7 53 1e          	movzwl 0x1e(%ebx),%edx
     701:	01 c2                	add    %eax,%edx
	while(nextCluster != FAT32_END_CHAIN) {
		// Read the FAT for this sector
		off = this->fatEntryOffsetForCluster(nextCluster);

		// Read out cluster
		if(this->read_sectors(off.sector, bpb.sectors_per_cluster, fatBuffer, &err)) {
     703:	8d 45 e0             	lea    -0x20(%ebp),%eax
     706:	89 44 24 10          	mov    %eax,0x10(%esp)
     70a:	8b 83 88 02 00 00    	mov    0x288(%ebx),%eax
 */
fat32_secoff_t fs_fat32::fatEntryOffsetForCluster(unsigned int cluster) {
	fat32_secoff_t offset;

	// Determine size of FAT and normalise cluster
	offset.sector = bpb.reserved_sector_count + (cluster / cluster_size);
     710:	89 55 d4             	mov    %edx,-0x2c(%ebp)
	while(nextCluster != FAT32_END_CHAIN) {
		// Read the FAT for this sector
		off = this->fatEntryOffsetForCluster(nextCluster);

		// Read out cluster
		if(this->read_sectors(off.sector, bpb.sectors_per_cluster, fatBuffer, &err)) {
     713:	89 44 24 0c          	mov    %eax,0xc(%esp)
     717:	0f b6 43 1d          	movzbl 0x1d(%ebx),%eax
     71b:	89 54 24 04          	mov    %edx,0x4(%esp)
     71f:	89 1c 24             	mov    %ebx,(%esp)
     722:	89 44 24 08          	mov    %eax,0x8(%esp)
     726:	e8 fc ff ff ff       	call   727 <_ZN8fs_fat3222clusterChainForClusterEj+0x9b>
     72b:	85 c0                	test   %eax,%eax
     72d:	0f 84 8d 00 00 00    	je     7c0 <_ZN8fs_fat3222clusterChainForClusterEj+0x134>
			nextCluster = fatBuffer[off.offset];
     733:	8b 93 88 02 00 00    	mov    0x288(%ebx),%edx
     739:	8b 45 d0             	mov    -0x30(%ebp),%eax
     73c:	8d 04 82             	lea    (%edx,%eax,4),%eax
			goto error;
		}

		// Is this the end of the chain?
		if(nextCluster >= FAT32_END_CHAIN) {
			nextCluster = FAT32_END_CHAIN;
     73f:	ba f8 ff ff 0f       	mov    $0xffffff8,%edx
		// Read the FAT for this sector
		off = this->fatEntryOffsetForCluster(nextCluster);

		// Read out cluster
		if(this->read_sectors(off.sector, bpb.sectors_per_cluster, fatBuffer, &err)) {
			nextCluster = fatBuffer[off.offset];
     744:	8b 08                	mov    (%eax),%ecx
			goto error;
		}

		// Is this the end of the chain?
		if(nextCluster >= FAT32_END_CHAIN) {
			nextCluster = FAT32_END_CHAIN;
     746:	81 f9 f8 ff ff 0f    	cmp    $0xffffff8,%ecx
     74c:	0f 43 ca             	cmovae %edx,%ecx
		}

		// Expand chain buffer
		if(chain_offset == chain_len) {
     74f:	3b 75 cc             	cmp    -0x34(%ebp),%esi
     752:	75 8c                	jne    6e0 <_ZN8fs_fat3222clusterChainForClusterEj+0x54>
			chain_len += 32;
     754:	8d 46 20             	lea    0x20(%esi),%eax
     757:	89 45 cc             	mov    %eax,-0x34(%ebp)
 * Follows the cluster chain to find all clusters on which the specified
 * starting cluster has data. This *can* be slow.
 *
 * Note that the array returned is terminated by FAT32_END_CHAIN.
 */
unsigned int *fs_fat32::clusterChainForCluster(unsigned int cluster) {
     75a:	c1 e0 02             	shl    $0x2,%eax
		}

		// Expand chain buffer
		if(chain_offset == chain_len) {
			chain_len += 32;
			chain = (unsigned int *) krealloc(chain, sizeof(unsigned int) * chain_len);
     75d:	89 3c 24             	mov    %edi,(%esp)
     760:	89 4d c8             	mov    %ecx,-0x38(%ebp)
     763:	89 44 24 04          	mov    %eax,0x4(%esp)
     767:	e8 fc ff ff ff       	call   768 <_ZN8fs_fat3222clusterChainForClusterEj+0xdc>
     76c:	8b 4d c8             	mov    -0x38(%ebp),%ecx
     76f:	89 c7                	mov    %eax,%edi
		}

		// Write into chain array
		chain[chain_offset++] = nextCluster & FAT32_MASK;
     771:	89 0c b7             	mov    %ecx,(%edi,%esi,4)
     774:	46                   	inc    %esi
	// Place the initial cluster as the first entry in the chain.
	chain[chain_offset++] = cluster;

	// Repeat until the end is reached (marked by FAT32_END_CHAIN)
	unsigned int nextCluster = cluster;
	while(nextCluster != FAT32_END_CHAIN) {
     775:	81 f9 f8 ff ff 0f    	cmp    $0xffffff8,%ecx
     77b:	0f 85 6f ff ff ff    	jne    6f0 <_ZN8fs_fat3222clusterChainForClusterEj+0x64>
     781:	eb 0d                	jmp    790 <_ZN8fs_fat3222clusterChainForClusterEj+0x104>
     783:	90                   	nop
     784:	90                   	nop
     785:	90                   	nop
     786:	90                   	nop
     787:	90                   	nop
     788:	90                   	nop
     789:	90                   	nop
     78a:	90                   	nop
     78b:	90                   	nop
     78c:	90                   	nop
     78d:	90                   	nop
     78e:	90                   	nop
     78f:	90                   	nop

	// Handle an error condition
	error: ;
	kfree(chain);
	return NULL;
}
     790:	8b 55 e4             	mov    -0x1c(%ebp),%edx
     793:	33 15 00 00 00 00    	xor    0x0,%edx
     799:	89 f8                	mov    %edi,%eax
     79b:	75 4b                	jne    7e8 <_ZN8fs_fat3222clusterChainForClusterEj+0x15c>
     79d:	83 c4 4c             	add    $0x4c,%esp
     7a0:	5b                   	pop    %ebx
     7a1:	5e                   	pop    %esi
     7a2:	5f                   	pop    %edi
     7a3:	5d                   	pop    %ebp
     7a4:	c3                   	ret    
     7a5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
     7a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	if(cluster == 0) {
		cluster = 2;
	}

	// Place the initial cluster as the first entry in the chain.
	chain[chain_offset++] = cluster;
     7b0:	c7 00 02 00 00 00    	movl   $0x2,(%eax)

	fat32_secoff_t off;

	// Guard against broken FS implementations
	if(cluster == 0) {
		cluster = 2;
     7b6:	ba 02 00 00 00       	mov    $0x2,%edx
     7bb:	e9 0b ff ff ff       	jmp    6cb <_ZN8fs_fat3222clusterChainForClusterEj+0x3f>

		// Read out cluster
		if(this->read_sectors(off.sector, bpb.sectors_per_cluster, fatBuffer, &err)) {
			nextCluster = fatBuffer[off.offset];
		} else { // error reading
			KERROR("Couldn't read sector %u for FAT", off.sector);
     7c0:	8b 55 d4             	mov    -0x2c(%ebp),%edx
     7c3:	b8 1c 0f 00 00       	mov    $0xf1c,%eax
     7c8:	89 44 24 04          	mov    %eax,0x4(%esp)
     7cc:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
     7d3:	89 54 24 08          	mov    %edx,0x8(%esp)
     7d7:	e8 fc ff ff ff       	call   7d8 <_ZN8fs_fat3222clusterChainForClusterEj+0x14c>

	return chain;

	// Handle an error condition
	error: ;
	kfree(chain);
     7dc:	89 3c 24             	mov    %edi,(%esp)
	return NULL;
     7df:	31 ff                	xor    %edi,%edi

	return chain;

	// Handle an error condition
	error: ;
	kfree(chain);
     7e1:	e8 fc ff ff ff       	call   7e2 <_ZN8fs_fat3222clusterChainForClusterEj+0x156>
	return NULL;
     7e6:	eb a8                	jmp    790 <_ZN8fs_fat3222clusterChainForClusterEj+0x104>
}
     7e8:	e8 fc ff ff ff       	call   7e9 <_ZN8fs_fat3222clusterChainForClusterEj+0x15d>
     7ed:	90                   	nop
     7ee:	66 90                	xchg   %ax,%ax

000007f0 <_ZN8fs_fat3211readClusterEjPvPj>:

/*
 * Reads the specified cluster.
 */
void *fs_fat32::readCluster(unsigned int cluster, void *buffer, unsigned int *error) {
     7f0:	55                   	push   %ebp
     7f1:	89 e5                	mov    %esp,%ebp
     7f3:	53                   	push   %ebx
     7f4:	83 ec 34             	sub    $0x34,%esp
     7f7:	8b 55 08             	mov    0x8(%ebp),%edx
     7fa:	a1 00 00 00 00       	mov    0x0,%eax
     7ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
     802:	31 c0                	xor    %eax,%eax
	unsigned int sector = ((cluster - 2) * bpb.sectors_per_cluster) + first_data_sector;

	if(!this->read_sectors(sector, bpb.sectors_per_cluster, buffer, error)) {
     804:	8b 45 14             	mov    0x14(%ebp),%eax
}

/*
 * Reads the specified cluster.
 */
void *fs_fat32::readCluster(unsigned int cluster, void *buffer, unsigned int *error) {
     807:	8b 5d 10             	mov    0x10(%ebp),%ebx
	unsigned int sector = ((cluster - 2) * bpb.sectors_per_cluster) + first_data_sector;
     80a:	0f b6 4a 1d          	movzbl 0x1d(%edx),%ecx

	if(!this->read_sectors(sector, bpb.sectors_per_cluster, buffer, error)) {
     80e:	89 44 24 10          	mov    %eax,0x10(%esp)

/*
 * Reads the specified cluster.
 */
void *fs_fat32::readCluster(unsigned int cluster, void *buffer, unsigned int *error) {
	unsigned int sector = ((cluster - 2) * bpb.sectors_per_cluster) + first_data_sector;
     812:	8b 45 0c             	mov    0xc(%ebp),%eax

	if(!this->read_sectors(sector, bpb.sectors_per_cluster, buffer, error)) {
     815:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
     819:	89 4c 24 08          	mov    %ecx,0x8(%esp)

/*
 * Reads the specified cluster.
 */
void *fs_fat32::readCluster(unsigned int cluster, void *buffer, unsigned int *error) {
	unsigned int sector = ((cluster - 2) * bpb.sectors_per_cluster) + first_data_sector;
     81d:	83 e8 02             	sub    $0x2,%eax
     820:	0f af c1             	imul   %ecx,%eax
     823:	8b 8a 78 02 00 00    	mov    0x278(%edx),%ecx

	if(!this->read_sectors(sector, bpb.sectors_per_cluster, buffer, error)) {
     829:	89 14 24             	mov    %edx,(%esp)

/*
 * Reads the specified cluster.
 */
void *fs_fat32::readCluster(unsigned int cluster, void *buffer, unsigned int *error) {
	unsigned int sector = ((cluster - 2) * bpb.sectors_per_cluster) + first_data_sector;
     82c:	01 c8                	add    %ecx,%eax

	if(!this->read_sectors(sector, bpb.sectors_per_cluster, buffer, error)) {
     82e:	89 44 24 04          	mov    %eax,0x4(%esp)
     832:	e8 fc ff ff ff       	call   833 <_ZN8fs_fat3211readClusterEjPvPj+0x43>
		return NULL;
     837:	85 c0                	test   %eax,%eax
     839:	b8 00 00 00 00       	mov    $0x0,%eax
     83e:	0f 44 d8             	cmove  %eax,%ebx
	}

	return buffer;
}
     841:	8b 55 f4             	mov    -0xc(%ebp),%edx
     844:	33 15 00 00 00 00    	xor    0x0,%edx
     84a:	89 d8                	mov    %ebx,%eax
     84c:	75 06                	jne    854 <_ZN8fs_fat3211readClusterEjPvPj+0x64>
     84e:	83 c4 34             	add    $0x34,%esp
     851:	5b                   	pop    %ebx
     852:	5d                   	pop    %ebp
     853:	c3                   	ret    
     854:	e8 fc ff ff ff       	call   855 <_ZN8fs_fat3211readClusterEjPvPj+0x65>
     859:	90                   	nop
     85a:	66 90                	xchg   %ax,%ax

0000085c <_ZN8fs_fat3213read_root_dirEv>:
}

/*
 * Read the root directory from the disk, bypassing caching.
 */
void fs_fat32::read_root_dir(void) {
     85c:	55                   	push   %ebp
     85d:	89 e5                	mov    %esp,%ebp
     85f:	57                   	push   %edi
     860:	56                   	push   %esi
     861:	53                   	push   %ebx
     862:	83 ec 3c             	sub    $0x3c,%esp
     865:	8b 5d 08             	mov    0x8(%ebp),%ebx
     868:	a1 00 00 00 00       	mov    0x0,%eax
     86d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
     870:	31 c0                	xor    %eax,%eax
	unsigned int err;

	// Release previous root directory, if it exists
	if(root_directory) {
     872:	8b 7b 04             	mov    0x4(%ebx),%edi
     875:	85 ff                	test   %edi,%edi
     877:	0f 84 53 01 00 00    	je     9d0 <_ZN8fs_fat3213read_root_dirEv+0x174>
		fs_directory_t *new_root = hal_vfs_allocate_directory(false);
     87d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
     884:	e8 fc ff ff ff       	call   885 <_ZN8fs_fat3213read_root_dirEv+0x29>

		hal_vfs_deallocate_directory(root_directory, new_root);
     889:	89 44 24 04          	mov    %eax,0x4(%esp)
void fs_fat32::read_root_dir(void) {
	unsigned int err;

	// Release previous root directory, if it exists
	if(root_directory) {
		fs_directory_t *new_root = hal_vfs_allocate_directory(false);
     88d:	89 c6                	mov    %eax,%esi

		hal_vfs_deallocate_directory(root_directory, new_root);
     88f:	8b 43 04             	mov    0x4(%ebx),%eax
     892:	89 04 24             	mov    %eax,(%esp)
     895:	e8 fc ff ff ff       	call   896 <_ZN8fs_fat3213read_root_dirEv+0x3a>
		kfree(root_dir);
     89a:	8b 83 84 02 00 00    	mov    0x284(%ebx),%eax
     8a0:	89 04 24             	mov    %eax,(%esp)
     8a3:	e8 fc ff ff ff       	call   8a4 <_ZN8fs_fat3213read_root_dirEv+0x48>

		root_directory = new_root;
     8a8:	89 73 04             	mov    %esi,0x4(%ebx)
	} else {
		root_directory = hal_vfs_allocate_directory(true);
	}

	// Follow the cluster chain for the root directory.
	unsigned int *root_clusters = this->clusterChainForCluster(bpb.root_cluster & FAT32_MASK);
     8ab:	8b 43 3c             	mov    0x3c(%ebx),%eax
     8ae:	89 1c 24             	mov    %ebx,(%esp)
     8b1:	25 ff ff ff 0f       	and    $0xfffffff,%eax
     8b6:	89 44 24 04          	mov    %eax,0x4(%esp)
     8ba:	e8 fc ff ff ff       	call   8bb <_ZN8fs_fat3213read_root_dirEv+0x5f>
	unsigned int cnt = 0;

	while(root_clusters[cnt] != FAT32_END_CHAIN) {
     8bf:	81 38 f8 ff ff 0f    	cmpl   $0xffffff8,(%eax)
	} else {
		root_directory = hal_vfs_allocate_directory(true);
	}

	// Follow the cluster chain for the root directory.
	unsigned int *root_clusters = this->clusterChainForCluster(bpb.root_cluster & FAT32_MASK);
     8c5:	89 c2                	mov    %eax,%edx
	unsigned int cnt = 0;

	while(root_clusters[cnt] != FAT32_END_CHAIN) {
     8c7:	0f 84 17 01 00 00    	je     9e4 <_ZN8fs_fat3213read_root_dirEv+0x188>
     8cd:	31 c0                	xor    %eax,%eax
     8cf:	90                   	nop
		cnt++;
     8d0:	40                   	inc    %eax

	// Follow the cluster chain for the root directory.
	unsigned int *root_clusters = this->clusterChainForCluster(bpb.root_cluster & FAT32_MASK);
	unsigned int cnt = 0;

	while(root_clusters[cnt] != FAT32_END_CHAIN) {
     8d1:	81 3c 82 f8 ff ff 0f 	cmpl   $0xffffff8,(%edx,%eax,4)
     8d8:	75 f6                	jne    8d0 <_ZN8fs_fat3213read_root_dirEv+0x74>
     8da:	8b b3 7c 02 00 00    	mov    0x27c(%ebx),%esi
     8e0:	0f af c6             	imul   %esi,%eax
     8e3:	89 c6                	mov    %eax,%esi
     8e5:	c1 ee 05             	shr    $0x5,%esi
		cnt++;
	}

	// Allocate memory for root directory
	unsigned int root_dir_len = cnt * cluster_size;
	root_dir = (fat_dirent_t *) kmalloc(root_dir_len);
     8e8:	89 55 d0             	mov    %edx,-0x30(%ebp)
     8eb:	89 04 24             	mov    %eax,(%esp)
     8ee:	e8 fc ff ff ff       	call   8ef <_ZN8fs_fat3213read_root_dirEv+0x93>
	root_dir_num_entries = root_dir_len / sizeof(fat_dirent_t);

	// Read the root directory's sectors.
	cnt = 0;
	while(true) {
		if(root_clusters[cnt] != FAT32_END_CHAIN) {
     8f3:	8b 55 d0             	mov    -0x30(%ebp),%edx
	}

	// Allocate memory for root directory
	unsigned int root_dir_len = cnt * cluster_size;
	root_dir = (fat_dirent_t *) kmalloc(root_dir_len);
	root_dir_num_entries = root_dir_len / sizeof(fat_dirent_t);
     8f6:	89 b3 80 02 00 00    	mov    %esi,0x280(%ebx)

	// Read the root directory's sectors.
	cnt = 0;
	while(true) {
		if(root_clusters[cnt] != FAT32_END_CHAIN) {
     8fc:	8b 3a                	mov    (%edx),%edi
		cnt++;
	}

	// Allocate memory for root directory
	unsigned int root_dir_len = cnt * cluster_size;
	root_dir = (fat_dirent_t *) kmalloc(root_dir_len);
     8fe:	89 83 84 02 00 00    	mov    %eax,0x284(%ebx)
	root_dir_num_entries = root_dir_len / sizeof(fat_dirent_t);

	// Read the root directory's sectors.
	cnt = 0;
	while(true) {
		if(root_clusters[cnt] != FAT32_END_CHAIN) {
     904:	81 ff f8 ff ff 0f    	cmp    $0xffffff8,%edi
     90a:	0f 84 7f 00 00 00    	je     98f <_ZN8fs_fat3213read_root_dirEv+0x133>
     910:	8b 8b 7c 02 00 00    	mov    0x27c(%ebx),%ecx
	unsigned int root_dir_len = cnt * cluster_size;
	root_dir = (fat_dirent_t *) kmalloc(root_dir_len);
	root_dir_num_entries = root_dir_len / sizeof(fat_dirent_t);

	// Read the root directory's sectors.
	cnt = 0;
     916:	31 f6                	xor    %esi,%esi
     918:	89 55 d4             	mov    %edx,-0x2c(%ebp)
     91b:	eb 1e                	jmp    93b <_ZN8fs_fat3213read_root_dirEv+0xdf>
     91d:	8d 76 00             	lea    0x0(%esi),%esi
	while(true) {
		if(root_clusters[cnt] != FAT32_END_CHAIN) {
     920:	8b 45 d4             	mov    -0x2c(%ebp),%eax
			}
		} else {
			break;
		}

		cnt++;
     923:	46                   	inc    %esi
	root_dir_num_entries = root_dir_len / sizeof(fat_dirent_t);

	// Read the root directory's sectors.
	cnt = 0;
	while(true) {
		if(root_clusters[cnt] != FAT32_END_CHAIN) {
     924:	8b 3c b0             	mov    (%eax,%esi,4),%edi
     927:	81 ff f8 ff ff 0f    	cmp    $0xffffff8,%edi
     92d:	74 51                	je     980 <_ZN8fs_fat3213read_root_dirEv+0x124>
     92f:	8b 83 84 02 00 00    	mov    0x284(%ebx),%eax
     935:	8b 8b 7c 02 00 00    	mov    0x27c(%ebx),%ecx
			unsigned int sector = root_clusters[cnt];

			if(!this->readCluster(root_clusters[cnt], root_dir + (cnt * cluster_size), &err)) {
     93b:	0f af ce             	imul   %esi,%ecx
     93e:	8d 55 e0             	lea    -0x20(%ebp),%edx
     941:	89 54 24 0c          	mov    %edx,0xc(%esp)
     945:	89 7c 24 04          	mov    %edi,0x4(%esp)
     949:	c1 e1 05             	shl    $0x5,%ecx
     94c:	01 c1                	add    %eax,%ecx
     94e:	89 4c 24 08          	mov    %ecx,0x8(%esp)
     952:	89 1c 24             	mov    %ebx,(%esp)
     955:	e8 fc ff ff ff       	call   956 <_ZN8fs_fat3213read_root_dirEv+0xfa>
     95a:	85 c0                	test   %eax,%eax
     95c:	75 c2                	jne    920 <_ZN8fs_fat3213read_root_dirEv+0xc4>
				KERROR("Error reading root dir sector %u: %u", sector, err);
     95e:	8b 45 e0             	mov    -0x20(%ebp),%eax
     961:	bb 48 0f 00 00       	mov    $0xf48,%ebx
     966:	89 7c 24 08          	mov    %edi,0x8(%esp)
     96a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
     96e:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
     975:	89 44 24 0c          	mov    %eax,0xc(%esp)
     979:	e8 fc ff ff ff       	call   97a <_ZN8fs_fat3213read_root_dirEv+0x11e>
				return;
     97e:	eb 34                	jmp    9b4 <_ZN8fs_fat3213read_root_dirEv+0x158>
     980:	8b 55 d4             	mov    -0x2c(%ebp),%edx
	root_dir_num_entries = root_dir_len / sizeof(fat_dirent_t);

	// Read the root directory's sectors.
	cnt = 0;
	while(true) {
		if(root_clusters[cnt] != FAT32_END_CHAIN) {
     983:	8b b3 80 02 00 00    	mov    0x280(%ebx),%esi
     989:	8b 83 84 02 00 00    	mov    0x284(%ebx),%eax

		cnt++;
	}

	// Process the read FAT directory entries into fs_file_t structs
	this->processFATDirEnt(root_dir, root_dir_num_entries, root_directory);
     98f:	8b 4b 04             	mov    0x4(%ebx),%ecx
     992:	89 55 d0             	mov    %edx,-0x30(%ebp)
     995:	89 74 24 08          	mov    %esi,0x8(%esp)
     999:	89 44 24 04          	mov    %eax,0x4(%esp)
     99d:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
     9a1:	89 1c 24             	mov    %ebx,(%esp)
     9a4:	e8 fc ff ff ff       	call   9a5 <_ZN8fs_fat3213read_root_dirEv+0x149>

	// Clean up temporary buffers needed to read root directory
	kfree(root_clusters);
     9a9:	8b 55 d0             	mov    -0x30(%ebp),%edx
     9ac:	89 14 24             	mov    %edx,(%esp)
     9af:	e8 fc ff ff ff       	call   9b0 <_ZN8fs_fat3213read_root_dirEv+0x154>
}
     9b4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
     9b7:	33 15 00 00 00 00    	xor    0x0,%edx
     9bd:	75 2e                	jne    9ed <_ZN8fs_fat3213read_root_dirEv+0x191>
     9bf:	83 c4 3c             	add    $0x3c,%esp
     9c2:	5b                   	pop    %ebx
     9c3:	5e                   	pop    %esi
     9c4:	5f                   	pop    %edi
     9c5:	5d                   	pop    %ebp
     9c6:	c3                   	ret    
     9c7:	89 f6                	mov    %esi,%esi
     9c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		hal_vfs_deallocate_directory(root_directory, new_root);
		kfree(root_dir);

		root_directory = new_root;
	} else {
		root_directory = hal_vfs_allocate_directory(true);
     9d0:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
     9d7:	e8 fc ff ff ff       	call   9d8 <_ZN8fs_fat3213read_root_dirEv+0x17c>
     9dc:	89 43 04             	mov    %eax,0x4(%ebx)
     9df:	e9 c7 fe ff ff       	jmp    8ab <_ZN8fs_fat3213read_root_dirEv+0x4f>

	// Follow the cluster chain for the root directory.
	unsigned int *root_clusters = this->clusterChainForCluster(bpb.root_cluster & FAT32_MASK);
	unsigned int cnt = 0;

	while(root_clusters[cnt] != FAT32_END_CHAIN) {
     9e4:	31 f6                	xor    %esi,%esi
     9e6:	31 c0                	xor    %eax,%eax
     9e8:	e9 fb fe ff ff       	jmp    8e8 <_ZN8fs_fat3213read_root_dirEv+0x8c>
	// Process the read FAT directory entries into fs_file_t structs
	this->processFATDirEnt(root_dir, root_dir_num_entries, root_directory);

	// Clean up temporary buffers needed to read root directory
	kfree(root_clusters);
}
     9ed:	e8 fc ff ff ff       	call   9ee <_ZN8fs_fat3213read_root_dirEv+0x192>
     9f2:	66 90                	xchg   %ax,%ax

000009f4 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk>:
#import <fat32.hpp>

/*
 * Initialises a FAT32 filesystem from the specified partition table entry.
 */
fs_fat32::fs_fat32(hal_disk_partition_t *p, hal_disk_t *d) : hal_fs::hal_fs(p, d) {
     9f4:	55                   	push   %ebp
     9f5:	89 e5                	mov    %esp,%ebp
     9f7:	57                   	push   %edi
     9f8:	56                   	push   %esi
     9f9:	53                   	push   %ebx
     9fa:	83 ec 3c             	sub    $0x3c,%esp
     9fd:	a1 00 00 00 00       	mov    0x0,%eax
     a02:	89 45 e4             	mov    %eax,-0x1c(%ebp)
     a05:	31 c0                	xor    %eax,%eax
     a07:	8b 45 10             	mov    0x10(%ebp),%eax
	unsigned int err = 0;

	// Read sector 0 of partition synchronously
	if(!read_sectors(0, 1, &bpb, &err)) {
     a0a:	8d 7d e0             	lea    -0x20(%ebp),%edi
#import <fat32.hpp>

/*
 * Initialises a FAT32 filesystem from the specified partition table entry.
 */
fs_fat32::fs_fat32(hal_disk_partition_t *p, hal_disk_t *d) : hal_fs::hal_fs(p, d) {
     a0d:	8b 5d 08             	mov    0x8(%ebp),%ebx
     a10:	89 44 24 08          	mov    %eax,0x8(%esp)
     a14:	8b 45 0c             	mov    0xc(%ebp),%eax
     a17:	89 1c 24             	mov    %ebx,(%esp)
     a1a:	89 44 24 04          	mov    %eax,0x4(%esp)
     a1e:	e8 fc ff ff ff       	call   a1f <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x2b>
	unsigned int err = 0;

	// Read sector 0 of partition synchronously
	if(!read_sectors(0, 1, &bpb, &err)) {
     a23:	8d 43 10             	lea    0x10(%ebx),%eax
#import <fat32.hpp>

/*
 * Initialises a FAT32 filesystem from the specified partition table entry.
 */
fs_fat32::fs_fat32(hal_disk_partition_t *p, hal_disk_t *d) : hal_fs::hal_fs(p, d) {
     a26:	c7 03 08 00 00 00    	movl   $0x8,(%ebx)
	unsigned int err = 0;

	// Read sector 0 of partition synchronously
	if(!read_sectors(0, 1, &bpb, &err)) {
     a2c:	89 44 24 0c          	mov    %eax,0xc(%esp)
     a30:	b8 01 00 00 00       	mov    $0x1,%eax
     a35:	89 44 24 08          	mov    %eax,0x8(%esp)
     a39:	31 c0                	xor    %eax,%eax

/*
 * Initialises a FAT32 filesystem from the specified partition table entry.
 */
fs_fat32::fs_fat32(hal_disk_partition_t *p, hal_disk_t *d) : hal_fs::hal_fs(p, d) {
	unsigned int err = 0;
     a3b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

	// Read sector 0 of partition synchronously
	if(!read_sectors(0, 1, &bpb, &err)) {
     a42:	89 7c 24 10          	mov    %edi,0x10(%esp)
     a46:	89 44 24 04          	mov    %eax,0x4(%esp)
     a4a:	89 1c 24             	mov    %ebx,(%esp)
     a4d:	e8 fc ff ff ff       	call   a4e <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x5a>
     a52:	85 c0                	test   %eax,%eax
     a54:	0f 84 b6 02 00 00    	je     d10 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x31c>
		KERROR("Error reading BPB: %u", err);
		return;
	}

	// Get data sector count
	root_dir_sectors = ((bpb.root_entry_count * 32) + (bpb.bytes_per_sector - 1)) / bpb.bytes_per_sector;
     a5a:	0f b7 43 21          	movzwl 0x21(%ebx),%eax
     a5e:	0f b7 4b 1b          	movzwl 0x1b(%ebx),%ecx

	num_data_sectors = bpb.total_sectors_32 - (bpb.reserved_sector_count + (bpb.table_count * bpb.table_size_32)) + root_dir_sectors;
     a62:	0f b7 73 1e          	movzwl 0x1e(%ebx),%esi
		KERROR("Error reading BPB: %u", err);
		return;
	}

	// Get data sector count
	root_dir_sectors = ((bpb.root_entry_count * 32) + (bpb.bytes_per_sector - 1)) / bpb.bytes_per_sector;
     a66:	c1 e0 05             	shl    $0x5,%eax
     a69:	8d 44 01 ff          	lea    -0x1(%ecx,%eax,1),%eax
     a6d:	99                   	cltd   
     a6e:	f7 f9                	idiv   %ecx

	num_data_sectors = bpb.total_sectors_32 - (bpb.reserved_sector_count + (bpb.table_count * bpb.table_size_32)) + root_dir_sectors;
     a70:	8b 53 30             	mov    0x30(%ebx),%edx
     a73:	29 f2                	sub    %esi,%edx
     a75:	0f b6 73 20          	movzbl 0x20(%ebx),%esi
     a79:	0f af 73 34          	imul   0x34(%ebx),%esi
     a7d:	29 f2                	sub    %esi,%edx
	num_data_clusters = num_data_sectors / bpb.sectors_per_cluster;
     a7f:	0f b6 73 1d          	movzbl 0x1d(%ebx),%esi

	// Calculate size of a cluster (in bytes)
	cluster_size = bpb.sectors_per_cluster * bpb.bytes_per_sector;
     a83:	0f af ce             	imul   %esi,%ecx
     a86:	89 8b 7c 02 00 00    	mov    %ecx,0x27c(%ebx)
		KERROR("Error reading BPB: %u", err);
		return;
	}

	// Get data sector count
	root_dir_sectors = ((bpb.root_entry_count * 32) + (bpb.bytes_per_sector - 1)) / bpb.bytes_per_sector;
     a8c:	89 83 6c 02 00 00    	mov    %eax,0x26c(%ebx)

	num_data_sectors = bpb.total_sectors_32 - (bpb.reserved_sector_count + (bpb.table_count * bpb.table_size_32)) + root_dir_sectors;
     a92:	01 d0                	add    %edx,%eax
	num_data_clusters = num_data_sectors / bpb.sectors_per_cluster;
     a94:	31 d2                	xor    %edx,%edx
	}

	// Get data sector count
	root_dir_sectors = ((bpb.root_entry_count * 32) + (bpb.bytes_per_sector - 1)) / bpb.bytes_per_sector;

	num_data_sectors = bpb.total_sectors_32 - (bpb.reserved_sector_count + (bpb.table_count * bpb.table_size_32)) + root_dir_sectors;
     a96:	89 83 74 02 00 00    	mov    %eax,0x274(%ebx)
	num_data_clusters = num_data_sectors / bpb.sectors_per_cluster;
     a9c:	f7 f6                	div    %esi
     a9e:	89 83 70 02 00 00    	mov    %eax,0x270(%ebx)

	// Calculate size of a cluster (in bytes)
	cluster_size = bpb.sectors_per_cluster * bpb.bytes_per_sector;
	KDEBUG("Cluster size of %u bytes", cluster_size);
     aa4:	b8 98 0f 00 00       	mov    $0xf98,%eax
     aa9:	89 4c 24 08          	mov    %ecx,0x8(%esp)
     aad:	89 44 24 04          	mov    %eax,0x4(%esp)
     ab1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
     ab8:	e8 fc ff ff ff       	call   ab9 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0xc5>

	// Calculate address of first data sector
	first_data_sector = bpb.reserved_sector_count + (bpb.table_count * bpb.table_size_32) + root_dir_sectors;
     abd:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
     ac1:	8b 73 34             	mov    0x34(%ebx),%esi
     ac4:	0f b7 53 1e          	movzwl 0x1e(%ebx),%edx
     ac8:	8b 8b 6c 02 00 00    	mov    0x26c(%ebx),%ecx
     ace:	0f af c6             	imul   %esi,%eax
     ad1:	01 ca                	add    %ecx,%edx
     ad3:	01 d0                	add    %edx,%eax
     ad5:	89 83 78 02 00 00    	mov    %eax,0x278(%ebx)

	// Determine volume type
	if(num_data_clusters < 4085) {
     adb:	8b 83 70 02 00 00    	mov    0x270(%ebx),%eax
     ae1:	3d f4 0f 00 00       	cmp    $0xff4,%eax
     ae6:	0f 86 04 02 00 00    	jbe    cf0 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x2fc>
		KERROR("Tried to initialise FAT12 volume as FAT32");
		return;
	} else if(num_data_clusters < 65525) { 
     aec:	3d f4 ff 00 00       	cmp    $0xfff4,%eax
     af1:	0f 86 39 01 00 00    	jbe    c30 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x23c>
		KERROR("Tried to initialise FAT16 volume as FAT32");
		return;
	}

	// Read FSINFO sector
	if(!read_sectors(bpb.fat_info, 1, &fs_info, &err)) {
     af7:	8d 43 6a             	lea    0x6a(%ebx),%eax
     afa:	89 44 24 0c          	mov    %eax,0xc(%esp)
     afe:	b8 01 00 00 00       	mov    $0x1,%eax
     b03:	89 7c 24 10          	mov    %edi,0x10(%esp)
     b07:	89 44 24 08          	mov    %eax,0x8(%esp)
     b0b:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
     b0f:	89 1c 24             	mov    %ebx,(%esp)
     b12:	89 44 24 04          	mov    %eax,0x4(%esp)
     b16:	e8 fc ff ff ff       	call   b17 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x123>
     b1b:	85 c0                	test   %eax,%eax
     b1d:	0f 84 0e 02 00 00    	je     d31 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x33d>
		KERROR("Error reading FSInfo: %u", err);
		return;
	}

	// Verify FSInfo struct
	if(fs_info.signature != 0x41615252 || fs_info.signature2 != 0x61417272 || fs_info.trailSig != 0xAA550000) {
     b23:	8b 43 6a             	mov    0x6a(%ebx),%eax
     b26:	3d 52 52 61 41       	cmp    $0x41615252,%eax
     b2b:	0f 84 5f 01 00 00    	je     c90 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x29c>
     b31:	8b 8b 66 02 00 00    	mov    0x266(%ebx),%ecx
     b37:	8b 93 4e 02 00 00    	mov    0x24e(%ebx),%edx
		KWARNING("Corrupted FSInfo: 0x%08X 0x%08X 0x%08X", 
			(unsigned int) fs_info.signature, (unsigned int) fs_info.signature2,
			(unsigned int) fs_info.trailSig);
     b3d:	be 48 10 00 00       	mov    $0x1048,%esi
     b42:	89 4c 24 10          	mov    %ecx,0x10(%esp)
     b46:	89 54 24 0c          	mov    %edx,0xc(%esp)
     b4a:	89 44 24 08          	mov    %eax,0x8(%esp)
     b4e:	89 74 24 04          	mov    %esi,0x4(%esp)
     b52:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
     b59:	e8 fc ff ff ff       	call   b5a <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x166>
			(unsigned int) fs_info.last_known_free_sec_cnt,
			(unsigned int) fs_info.free_cluster_search_start);
	}

	// Allocate various kinds of buffers
	fatBuffer = (uint32_t *) kmalloc(cluster_size);
     b5e:	8b 83 7c 02 00 00    	mov    0x27c(%ebx),%eax
     b64:	89 04 24             	mov    %eax,(%esp)
     b67:	e8 fc ff ff ff       	call   b68 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x174>
     b6c:	89 83 88 02 00 00    	mov    %eax,0x288(%ebx)

	this->read_root_dir();
     b72:	89 1c 24             	mov    %ebx,(%esp)
     b75:	e8 fc ff ff ff       	call   b76 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x182>

	// List it
	KDEBUG("Root directory: %u items", root_directory->children->num_entries);
     b7a:	8b 43 04             	mov    0x4(%ebx),%eax
     b7d:	8b 40 1c             	mov    0x1c(%eax),%eax
     b80:	8b 40 08             	mov    0x8(%eax),%eax
     b83:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
     b8a:	89 44 24 08          	mov    %eax,0x8(%esp)
     b8e:	b8 b0 10 00 00       	mov    $0x10b0,%eax
     b93:	89 44 24 04          	mov    %eax,0x4(%esp)
     b97:	e8 fc ff ff ff       	call   b98 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x1a4>
	for(unsigned int i = 0; i < root_directory->children->num_entries; i++) {
     b9c:	8b 43 04             	mov    0x4(%ebx),%eax
     b9f:	8b 40 1c             	mov    0x1c(%eax),%eax
     ba2:	8b 50 08             	mov    0x8(%eax),%edx
     ba5:	85 d2                	test   %edx,%edx
     ba7:	74 67                	je     c10 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x21c>
     ba9:	31 f6                	xor    %esi,%esi
     bab:	eb 1b                	jmp    bc8 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x1d4>
     bad:	8d 76 00             	lea    0x0(%esi),%esi

		if(item->type == kFSItemTypeFile) {
			fs_file_t *file = (fs_file_t *) item;

			KDEBUG("File: %s", file->i.name);
		} else if(item->type == kFSItemTypeDirectory) {
     bb0:	81 fa 45 52 49 44    	cmp    $0x44495245,%edx
     bb6:	0f 84 a4 00 00 00    	je     c60 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x26c>

	this->read_root_dir();

	// List it
	KDEBUG("Root directory: %u items", root_directory->children->num_entries);
	for(unsigned int i = 0; i < root_directory->children->num_entries; i++) {
     bbc:	8b 43 04             	mov    0x4(%ebx),%eax
     bbf:	46                   	inc    %esi
     bc0:	8b 40 1c             	mov    0x1c(%eax),%eax
     bc3:	39 70 08             	cmp    %esi,0x8(%eax)
     bc6:	76 48                	jbe    c10 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x21c>
		fs_item_t *item = (fs_item_t *) list_get(root_directory->children, i);
     bc8:	89 74 24 04          	mov    %esi,0x4(%esp)
     bcc:	89 04 24             	mov    %eax,(%esp)
     bcf:	e8 fc ff ff ff       	call   bd0 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x1dc>

		if(item->type == kFSItemTypeFile) {
     bd4:	8b 10                	mov    (%eax),%edx
     bd6:	81 fa 45 4c 49 46    	cmp    $0x46494c45,%edx
     bdc:	75 d2                	jne    bb0 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x1bc>
			fs_file_t *file = (fs_file_t *) item;

			KDEBUG("File: %s", file->i.name);
     bde:	8b 40 04             	mov    0x4(%eax),%eax

	this->read_root_dir();

	// List it
	KDEBUG("Root directory: %u items", root_directory->children->num_entries);
	for(unsigned int i = 0; i < root_directory->children->num_entries; i++) {
     be1:	46                   	inc    %esi
		fs_item_t *item = (fs_item_t *) list_get(root_directory->children, i);

		if(item->type == kFSItemTypeFile) {
			fs_file_t *file = (fs_file_t *) item;

			KDEBUG("File: %s", file->i.name);
     be2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
     be9:	89 44 24 08          	mov    %eax,0x8(%esp)
     bed:	b8 d5 0e 00 00       	mov    $0xed5,%eax
     bf2:	89 44 24 04          	mov    %eax,0x4(%esp)
     bf6:	e8 fc ff ff ff       	call   bf7 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x203>

	this->read_root_dir();

	// List it
	KDEBUG("Root directory: %u items", root_directory->children->num_entries);
	for(unsigned int i = 0; i < root_directory->children->num_entries; i++) {
     bfb:	8b 43 04             	mov    0x4(%ebx),%eax
     bfe:	8b 40 1c             	mov    0x1c(%eax),%eax
     c01:	39 70 08             	cmp    %esi,0x8(%eax)
     c04:	77 c2                	ja     bc8 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x1d4>
     c06:	8d 76 00             	lea    0x0(%esi),%esi
     c09:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		}
	}

	// root_directory = this->contents_of_directory((char *) "/boot/grub/");

	KSUCCESS("Volume initialised.");
     c10:	b8 fb 0e 00 00       	mov    $0xefb,%eax
     c15:	89 44 24 04          	mov    %eax,0x4(%esp)
     c19:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
     c20:	e8 fc ff ff ff       	call   c21 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x22d>
     c25:	eb 1e                	jmp    c45 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x251>
     c27:	89 f6                	mov    %esi,%esi
     c29:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	// Determine volume type
	if(num_data_clusters < 4085) {
		KERROR("Tried to initialise FAT12 volume as FAT32");
		return;
	} else if(num_data_clusters < 65525) { 
		KERROR("Tried to initialise FAT16 volume as FAT32");
     c30:	b8 f0 0f 00 00       	mov    $0xff0,%eax
     c35:	89 44 24 04          	mov    %eax,0x4(%esp)
     c39:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
     c40:	e8 fc ff ff ff       	call   c41 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x24d>
	}

	// root_directory = this->contents_of_directory((char *) "/boot/grub/");

	KSUCCESS("Volume initialised.");
}
     c45:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     c48:	33 05 00 00 00 00    	xor    0x0,%eax
     c4e:	0f 85 fe 00 00 00    	jne    d52 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x35e>
     c54:	83 c4 3c             	add    $0x3c,%esp
     c57:	5b                   	pop    %ebx
     c58:	5e                   	pop    %esi
     c59:	5f                   	pop    %edi
     c5a:	5d                   	pop    %ebp
     c5b:	c3                   	ret    
     c5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

			KDEBUG("File: %s", file->i.name);
		} else if(item->type == kFSItemTypeDirectory) {
			fs_directory_t *dir = (fs_directory_t *) item;

			KDEBUG(" Dir: %s", dir->i.name);
     c60:	8b 40 04             	mov    0x4(%eax),%eax
     c63:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
     c6a:	89 44 24 08          	mov    %eax,0x8(%esp)
     c6e:	b8 e8 0e 00 00       	mov    $0xee8,%eax
     c73:	89 44 24 04          	mov    %eax,0x4(%esp)
     c77:	e8 fc ff ff ff       	call   c78 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x284>
     c7c:	e9 3b ff ff ff       	jmp    bbc <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x1c8>
     c81:	eb 0d                	jmp    c90 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x29c>
     c83:	90                   	nop
     c84:	90                   	nop
     c85:	90                   	nop
     c86:	90                   	nop
     c87:	90                   	nop
     c88:	90                   	nop
     c89:	90                   	nop
     c8a:	90                   	nop
     c8b:	90                   	nop
     c8c:	90                   	nop
     c8d:	90                   	nop
     c8e:	90                   	nop
     c8f:	90                   	nop
		KERROR("Error reading FSInfo: %u", err);
		return;
	}

	// Verify FSInfo struct
	if(fs_info.signature != 0x41615252 || fs_info.signature2 != 0x61417272 || fs_info.trailSig != 0xAA550000) {
     c90:	8b 93 4e 02 00 00    	mov    0x24e(%ebx),%edx
     c96:	8b 8b 66 02 00 00    	mov    0x266(%ebx),%ecx
     c9c:	81 fa 72 72 41 61    	cmp    $0x61417272,%edx
     ca2:	0f 85 95 fe ff ff    	jne    b3d <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x149>
     ca8:	81 f9 00 00 55 aa    	cmp    $0xaa550000,%ecx
     cae:	0f 85 89 fe ff ff    	jne    b3d <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x149>
			(unsigned int) fs_info.trailSig);
	} else {
		KDEBUG("%u clusters, %u free, start search at %u",
			(unsigned int) num_data_clusters,
			(unsigned int) fs_info.last_known_free_sec_cnt,
			(unsigned int) fs_info.free_cluster_search_start);
     cb4:	8b 83 56 02 00 00    	mov    0x256(%ebx),%eax
     cba:	b9 7c 10 00 00       	mov    $0x107c,%ecx
     cbf:	89 44 24 10          	mov    %eax,0x10(%esp)
     cc3:	8b 83 52 02 00 00    	mov    0x252(%ebx),%eax
     cc9:	89 44 24 0c          	mov    %eax,0xc(%esp)
     ccd:	8b 83 70 02 00 00    	mov    0x270(%ebx),%eax
     cd3:	89 4c 24 04          	mov    %ecx,0x4(%esp)
     cd7:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
     cde:	89 44 24 08          	mov    %eax,0x8(%esp)
     ce2:	e8 fc ff ff ff       	call   ce3 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x2ef>
     ce7:	e9 72 fe ff ff       	jmp    b5e <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x16a>
     cec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	// Calculate address of first data sector
	first_data_sector = bpb.reserved_sector_count + (bpb.table_count * bpb.table_size_32) + root_dir_sectors;

	// Determine volume type
	if(num_data_clusters < 4085) {
		KERROR("Tried to initialise FAT12 volume as FAT32");
     cf0:	b8 bc 0f 00 00       	mov    $0xfbc,%eax
     cf5:	89 44 24 04          	mov    %eax,0x4(%esp)
     cf9:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
     d00:	e8 fc ff ff ff       	call   d01 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x30d>
		return;
     d05:	e9 3b ff ff ff       	jmp    c45 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x251>
     d0a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
fs_fat32::fs_fat32(hal_disk_partition_t *p, hal_disk_t *d) : hal_fs::hal_fs(p, d) {
	unsigned int err = 0;

	// Read sector 0 of partition synchronously
	if(!read_sectors(0, 1, &bpb, &err)) {
		KERROR("Error reading BPB: %u", err);
     d10:	8b 45 e0             	mov    -0x20(%ebp),%eax
     d13:	bf 78 0f 00 00       	mov    $0xf78,%edi
     d18:	89 7c 24 04          	mov    %edi,0x4(%esp)
     d1c:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
     d23:	89 44 24 08          	mov    %eax,0x8(%esp)
     d27:	e8 fc ff ff ff       	call   d28 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x334>
		return;
     d2c:	e9 14 ff ff ff       	jmp    c45 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x251>
		return;
	}

	// Read FSINFO sector
	if(!read_sectors(bpb.fat_info, 1, &fs_info, &err)) {
		KERROR("Error reading FSInfo: %u", err);
     d31:	8b 45 e0             	mov    -0x20(%ebp),%eax
     d34:	bf 24 10 00 00       	mov    $0x1024,%edi
     d39:	89 7c 24 04          	mov    %edi,0x4(%esp)
     d3d:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
     d44:	89 44 24 08          	mov    %eax,0x8(%esp)
     d48:	e8 fc ff ff ff       	call   d49 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x355>
		return;
     d4d:	e9 f3 fe ff ff       	jmp    c45 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x251>
	}

	// root_directory = this->contents_of_directory((char *) "/boot/grub/");

	KSUCCESS("Volume initialised.");
}
     d52:	e8 fc ff ff ff       	call   d53 <_ZN8fs_fat32C1EP18hal_disk_partitionP8hal_disk+0x35f>
	...

00000d58 <_ZL17fat32_part_verifyP18hal_disk_partition>:
}

/*
 * Verifies if the FAT32 driver can support the partition.
 */
static bool fat32_part_verify(hal_disk_partition_t *part) {
     d58:	55                   	push   %ebp
     d59:	89 e5                	mov    %esp,%ebp
     d5b:	83 ec 18             	sub    $0x18,%esp
     d5e:	a1 00 00 00 00       	mov    0x0,%eax
     d63:	89 45 f4             	mov    %eax,-0xc(%ebp)
     d66:	31 c0                	xor    %eax,%eax
     d68:	8b 45 08             	mov    0x8(%ebp),%eax
     d6b:	80 38 0c             	cmpb   $0xc,(%eax)
     d6e:	0f 94 c0             	sete   %al
	if(part->type == 0x0C) {
		return true;
	}

	return false;
}
     d71:	8b 55 f4             	mov    -0xc(%ebp),%edx
     d74:	33 15 00 00 00 00    	xor    0x0,%edx
     d7a:	75 02                	jne    d7e <_ZL17fat32_part_verifyP18hal_disk_partition+0x26>
     d7c:	c9                   	leave  
     d7d:	c3                   	ret    
     d7e:	e8 fc ff ff ff       	call   d7f <_ZL17fat32_part_verifyP18hal_disk_partition+0x27>
     d83:	90                   	nop

00000d84 <_ZL23fat32_create_superblocKP18hal_disk_partitionP8hal_disk>:
 * Creates a superblock (in this case, the fat32/fat16 classes) for the
 * appropriate partition.
 *
 * This code assumes it's only called if it's a FAT fs, which is usually true.
 */
static void *fat32_create_superblocK(hal_disk_partition_t *part, hal_disk_t *disk) {
     d84:	55                   	push   %ebp
     d85:	89 e5                	mov    %esp,%ebp
     d87:	83 ec 38             	sub    $0x38,%esp
     d8a:	89 5d f8             	mov    %ebx,-0x8(%ebp)
     d8d:	8b 5d 08             	mov    0x8(%ebp),%ebx
     d90:	89 75 fc             	mov    %esi,-0x4(%ebp)
     d93:	8b 75 0c             	mov    0xc(%ebp),%esi
     d96:	a1 00 00 00 00       	mov    0x0,%eax
     d9b:	89 45 f4             	mov    %eax,-0xc(%ebp)
     d9e:	31 c0                	xor    %eax,%eax
	// FAT32
	if(part->type == 0x0C) {
     da0:	80 3b 0c             	cmpb   $0xc,(%ebx)
     da3:	75 22                	jne    dc7 <_ZL23fat32_create_superblocKP18hal_disk_partitionP8hal_disk+0x43>
		return (void *) new fs_fat32(part, disk);
     da5:	c7 04 24 8c 02 00 00 	movl   $0x28c,(%esp)
     dac:	e8 fc ff ff ff       	call   dad <_ZL23fat32_create_superblocKP18hal_disk_partitionP8hal_disk+0x29>
     db1:	89 74 24 08          	mov    %esi,0x8(%esp)
     db5:	89 5c 24 04          	mov    %ebx,0x4(%esp)
     db9:	89 04 24             	mov    %eax,(%esp)
     dbc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
     dbf:	e8 fc ff ff ff       	call   dc0 <_ZL23fat32_create_superblocKP18hal_disk_partitionP8hal_disk+0x3c>
     dc4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	}

	return NULL;
     dc7:	8b 55 f4             	mov    -0xc(%ebp),%edx
     dca:	33 15 00 00 00 00    	xor    0x0,%edx
     dd0:	75 0a                	jne    ddc <_ZL23fat32_create_superblocKP18hal_disk_partitionP8hal_disk+0x58>
     dd2:	8b 5d f8             	mov    -0x8(%ebp),%ebx
     dd5:	8b 75 fc             	mov    -0x4(%ebp),%esi
     dd8:	89 ec                	mov    %ebp,%esp
     dda:	5d                   	pop    %ebp
     ddb:	c3                   	ret    
     ddc:	e8 fc ff ff ff       	call   ddd <_ZL23fat32_create_superblocKP18hal_disk_partitionP8hal_disk+0x59>
     de1:	8d 76 00             	lea    0x0(%esi),%esi

00000de4 <start>:

/*
 * Initialisation function for the FAT32 driver (called by kernel)
 */
extern "C" {
	module_t *start(void) {
     de4:	55                   	push   %ebp
     de5:	89 e5                	mov    %esp,%ebp
     de7:	83 ec 28             	sub    $0x28,%esp
     dea:	a1 00 00 00 00       	mov    0x0,%eax
     def:	89 45 f4             	mov    %eax,-0xc(%ebp)
     df2:	31 c0                	xor    %eax,%eax
		hal_vfs_register((hal_vfs_t *) &vfs);
     df4:	c7 04 24 20 0e 00 00 	movl   $0xe20,(%esp)
     dfb:	e8 fc ff ff ff       	call   dfc <start+0x18>
		return (module_t *) &mod;
	}
     e00:	b8 60 0e 00 00       	mov    $0xe60,%eax
     e05:	8b 55 f4             	mov    -0xc(%ebp),%edx
     e08:	33 15 00 00 00 00    	xor    0x0,%edx
     e0e:	75 02                	jne    e12 <start+0x2e>
     e10:	c9                   	leave  
     e11:	c3                   	ret    
     e12:	e8 fc ff ff ff       	call   e13 <start+0x2f>
	...

00000e20 <_ZL3vfs>:
     e20:	46 41 54 33 32 00 00 00 00 00 00 00 00 00 00 00     FAT32...........
	...
     e40:	58 0d 00 00 84 0d 00 00 00 00 00 00 00 00 00 00     X...............
	...

00000e60 <_ZL3mod>:
     e60:	66 73 5f 66 61 74 33 32 00 00 00 00 00 00 00 00     fs_fat32........
	...
     eac:	66 73 5f 66 61 74 33 32 3a 20 25 73 00 72 6f 6f     fs_fat32: %s.roo
     ebc:	74 00 66 61 74 33 32 2e 63 70 70 00 65 6e 74 72     t.fat32.cpp.entr
     ecc:	69 65 73 00 2e 00 2e 2e 00 66 73 5f 66 61 74 33     ies......fs_fat3
     edc:	32 3a 20 46 69 6c 65 3a 20 25 73 00 66 73 5f 66     2: File: %s.fs_f
     eec:	61 74 33 32 3a 20 20 44 69 72 3a 20 25 73 00 66     at32:  Dir: %s.f
     efc:	73 5f 66 61 74 33 32 3a 20 56 6f 6c 75 6d 65 20     s_fat32: Volume 
     f0c:	69 6e 69 74 69 61 6c 69 73 65 64 2e 00 00 00 00     initialised.....
     f1c:	66 73 5f 66 61 74 33 32 3a 20 43 6f 75 6c 64 6e     fs_fat32: Couldn
     f2c:	27 74 20 72 65 61 64 20 73 65 63 74 6f 72 20 25     't read sector %
     f3c:	75 20 66 6f 72 20 46 41 54 00 00 00 66 73 5f 66     u for FAT...fs_f
     f4c:	61 74 33 32 3a 20 45 72 72 6f 72 20 72 65 61 64     at32: Error read
     f5c:	69 6e 67 20 72 6f 6f 74 20 64 69 72 20 73 65 63     ing root dir sec
     f6c:	74 6f 72 20 25 75 3a 20 25 75 00 00 66 73 5f 66     tor %u: %u..fs_f
     f7c:	61 74 33 32 3a 20 45 72 72 6f 72 20 72 65 61 64     at32: Error read
     f8c:	69 6e 67 20 42 50 42 3a 20 25 75 00 66 73 5f 66     ing BPB: %u.fs_f
     f9c:	61 74 33 32 3a 20 43 6c 75 73 74 65 72 20 73 69     at32: Cluster si
     fac:	7a 65 20 6f 66 20 25 75 20 62 79 74 65 73 00 00     ze of %u bytes..
     fbc:	66 73 5f 66 61 74 33 32 3a 20 54 72 69 65 64 20     fs_fat32: Tried 
     fcc:	74 6f 20 69 6e 69 74 69 61 6c 69 73 65 20 46 41     to initialise FA
     fdc:	54 31 32 20 76 6f 6c 75 6d 65 20 61 73 20 46 41     T12 volume as FA
     fec:	54 33 32 00 66 73 5f 66 61 74 33 32 3a 20 54 72     T32.fs_fat32: Tr
     ffc:	69 65 64 20 74 6f 20 69 6e 69 74 69 61 6c 69 73     ied to initialis
    100c:	65 20 46 41 54 31 36 20 76 6f 6c 75 6d 65 20 61     e FAT16 volume a
    101c:	73 20 46 41 54 33 32 00 66 73 5f 66 61 74 33 32     s FAT32.fs_fat32
    102c:	3a 20 45 72 72 6f 72 20 72 65 61 64 69 6e 67 20     : Error reading 
    103c:	46 53 49 6e 66 6f 3a 20 25 75 00 00 66 73 5f 66     FSInfo: %u..fs_f
    104c:	61 74 33 32 3a 20 43 6f 72 72 75 70 74 65 64 20     at32: Corrupted 
    105c:	46 53 49 6e 66 6f 3a 20 30 78 25 30 38 58 20 30     FSInfo: 0x%08X 0
    106c:	78 25 30 38 58 20 30 78 25 30 38 58 00 00 00 00     x%08X 0x%08X....
    107c:	66 73 5f 66 61 74 33 32 3a 20 25 75 20 63 6c 75     fs_fat32: %u clu
    108c:	73 74 65 72 73 2c 20 25 75 20 66 72 65 65 2c 20     sters, %u free, 
    109c:	73 74 61 72 74 20 73 65 61 72 63 68 20 61 74 20     start search at 
    10ac:	25 75 00 00 66 73 5f 66 61 74 33 32 3a 20 52 6f     %u..fs_fat32: Ro
    10bc:	6f 74 20 64 69 72 65 63 74 6f 72 79 3a 20 25 75     ot directory: %u
    10cc:	20 69 74 65 6d 73 00                                 items.
